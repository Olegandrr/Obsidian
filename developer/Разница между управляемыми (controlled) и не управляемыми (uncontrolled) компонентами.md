![Разница между управляемыми (controlled) и не управляемыми (uncontrolled) компонентами?](https://youtu.be/yvOXvZ8aEFo?t=684)

#### Ответ

Одна из основных идей React, это наличие контроля над компонентами и управление их собственным состоянием. Что случится если мы отправим чистый HTML элементов формы (input, select, textarea и т.д.) в общей куче? Должны ли мы иметь React, как “единственный источник правды” или мы должны позволить, чтобы данные формы существовали в DOM в HTML-форме? Эти два вопроса лежат в основе **контролируемых (controlled)** и **неконтролируемых** (**uncontrolled)** компонентов.

**Контролируемый** компонент — это такой компонент, где React осуществляет контроль и является единственным источником правды для данных формы. Как вы можете видеть ниже, _username_ существует не в DOM, а нашем состоянии компонента. Всякий раз, когда хотим обновить _username_, мы вызываем _setState,_ как мы уже привыкли.
```
class ControlledForm extends Component {  
  state = {  
    username: ''  
  }  
  updateUsername = (e) => {  
    this.setState({  
      username: e.target.value,  
    })  
  }  
  handleSubmit = () => {}  
  render () {  
    return (  
      <form onSubmit={this.handleSubmit}>  
        <input  
          type='text'  
          value={this.state.username}  
          onChange={this.updateUsername} />  
        <button type='submit'>Submit</button>  
      </form>  
    )  
  }  
}
```
**Некотролируемый** компонент — это такой компонент, где ваши данные формы обрабатываются в DOM, а не внутри вашего компонента.
```
class UnControlledForm extends Component {  
  handleSubmit = () => {  
    console.log("Input Value: ", this.input.value)  
  }  
  render () {  
    return (  
      <form onSubmit={this.handleSubmit}>  
        <input  
          type='text'  
          ref={(input) => this.input = input} />  
        <button type='submit'>Submit</button>  
      </form>  
    )  
  }  
}
```
Хотя неконтролируемые компоненты обычно проще в реализации, так как вы просто берете значение из DOM используя refs, рекомендуется использовать контролируемые компоненты. Основная причина этого в том, что контролируемые компоненты поддерживают мгновенную проверку полей, позволяют вам условно отключать/включать кнопки, устанавливать формат входных данных и, вообще, более отражают суть React.


Подробнее: [Контролируемый и неконтролируемый компонент](https://habr.com/ru/post/502034/)

##### Краткое описание

Компонент становится контролируемым, когда вы устанавливаете его значение используя props. 

**Пример**
Например, у меня есть функция добавления задачи onSubmit ,
в ней есть preventDefault и функция очищение формы через setState с пустой " " по факту ввода значения .
setState изменяет состояние а #react понимает что нужно выполнить функцию render и надо выполнить фунцию value и её выполнение не приводит к событию.

На onSubmit - это функция добавления задачи и её очищения после ввода. На изменение **input** мы вешаем обработчик клика, который при каждом новом вводе сет-стейтит новое значение value, полученное из **event**-объекта ;

А при каждой отрисовке значение инпута берется из стейта. Выходит что инпут буквально находится под контролем у стейта — отправляет новые значения в него и читает оттуда же.

##### Подробнее [Контролируемые компоненты](https://makeweb.me/anatomiya-react-dlya-nachinayushhih-urok-9-spiski-i-formy-ne-kontroliruemye-komponenty/)

Компонент становится контролируемым, когда вы устанавливаете его значение используя props. Вот и всё.  

  ![[Pasted image 20230320183637.png]]

onChange() - обновляет state, а state обновляется value элемента.

Давайте посмотрим на пример кода.

```
import React, { Component } from 'react';

class App extends Component {
    state = {
        message: ''
    }
    updateMessage = (newText) => {
        console.log(newText);
        this.setState(() => ({
            message: newText
        }));
    }
    render() {
        return (
            <div classname="App">
                <div classname="container">
                    <input type="text" placeholder="Your message here.." value="{this.state.message}" onchange="{(event)" ==""> this.updateMessage(event.target.value)}
                    />
                    <p>the message is: {this.state.message}</p>
                </div>
            </div>
        );
    }
}

export default App;
```

Если мы посмотрим на код для этого компонента, в строке 4 мы создаем объект состояния. Он содержит единственное свойство, которое называется `message`. Здесь хранится значение, введенное в текстовое поле.

Чтобы сохранить значение, нам нужно событие, которое будет запущено, когда пользователь вводит текст в поле. Как мы это делаем?

Если вы посмотрите на строки 19 и 20 кода, вы увидите, что:

1.  Текстовое поле имеет атрибут value, связанный со свойством сообщения в состоянии.
2.  У нас есть обработчик события `onChange`.

Эти 2 пункта говорят вам, что это контролируемый компонент.

Нам не нужен элемент формы на странице, чтобы компонент был контролируемым компонентом.

Когда вносятся изменения в любой из элементов ввода, имеющих обработчик события, он запускается.

Обработчик вызывает `setState()`, как вы можете видеть в строке 9 выше. Это обновляет состояние внутри компонента.

Вы никогда не должны устанавливать состояние прямо так:

```
this.state.message = 'dont update state like this';
```

Обновление состояния таким способом не вызовет повторную визуализацию компонента, а сделанные пользователем изменения не будут отображаться в пользовательском интерфейсе.

Когда обновление состояния происходит через `setState()`, это вызывает повторную визуализацию компонента, и вновь введенное значение отображается в элементе.

Поток данных является однонаправленным от состояния компонента к элементу ввода.

Работа с контролируемыми компонентами может быть немного громоздкой. Если на странице имеется большое количество элементов ввода, каждый элемент требует настройки с атрибутом значения и обработчиком события.


____
#react

____

#### [[004 React + Redux|Назад]]