# 73. Get, Set

## [Дескрипторы в примерах](https://learn.javascript.ru/descriptors-getters-setters#deskriptory-v-primerah)

Основной метод для управления свойствами – [Object.defineProperty](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/defineProperty).

Он позволяет объявить свойство объекта и, что самое главное, тонко настроить его особые аспекты, которые никак иначе не изменить.

Синтаксис:

```
Object
```

Аргументы:

`**obj**`

Объект, в котором объявляется свойство.

`**prop**`

Имя свойства, которое нужно объявить или модифицировать.

`**descriptor**`

Дескриптор – объект, который описывает поведение свойства.

В нём могут быть следующие поля:

·         `value` – значение свойства, по умолчанию `undefined`

·         `writable` – значение свойства можно менять, если `true`. По умолчанию `false`.

·         `configurable` – если `true`, то свойство можно удалять, а также менять его в дальнейшем при помощи новых вызовов `defineProperty`. По умолчанию `false`.

·         `enumerable` – если `true`, то свойство просматривается в цикле `for..in` и методе `Object.keys()`. По умолчанию `false`.

·         `get` – функция, которая возвращает значение свойства. По умолчанию `undefined`.

·         `set` – функция, которая записывает значение свойства. По умолчанию `undefined`.

Чтобы избежать конфликта, запрещено одновременно указывать значение `value` и функции `get/set`. Либо значение, либо функции для его чтения-записи, одно из двух. Также запрещено и не имеет смысла указывать `writable` при наличии `get/set`-функций.

Далее мы подробно разберём эти свойства на примерах.

[Обычное свойство](https://learn.javascript.ru/descriptors-getters-setters#obychnoe-svoystvo)

Два таких вызова работают одинаково:

var `user` = {};

// 1. простое присваивание

```
user
```

// 2. указание значения через дескриптор

```
Object
```

Оба вызова выше добавляют в объект `user` обычное (удаляемое, изменяемое, перечисляемое) свойство.

[Свойство-константа](https://learn.javascript.ru/descriptors-getters-setters#svoystvo-konstanta)

Для того, чтобы сделать свойство неизменяемым, изменим его флаги `writable` и `configurable`:

"use strict";

var `user` = {};

```
Object
```

```
  value
```

  _writable_: false, // запретить присвоение "user.name="

  _configurable_: false // запретить удаление "delete user.name"

});

// Теперь попытаемся изменить это свойство.

// в strict mode присвоение "user.name=" вызовет ошибку

_user_._name_ = "Петя";

Заметим, что без `use strict` операция записи «молча» не сработает. Лишь если установлен режим `use strict`, то дополнительно сгенерируется ошибка.

[Свойство, скрытое для for…in](https://learn.javascript.ru/descriptors-getters-setters#svoystvo-skrytoe-dlya-for-in)

Встроенный метод `toString`, как и большинство встроенных методов, не участвует в цикле `for..in`. Это удобно, так как обычно такое свойство является «служебным».

К сожалению, свойство `toString`, объявленное обычным способом, будет видно в цикле `for..in`, например:

var `user` = {

```
  name
```

```
  
```

};

for(var _key_ in _user_) alert(_key_);  // name, toString

Мы бы хотели, чтобы поведение нашего метода `toString` было таким же, как и стандартного.

`Object.defineProperty` может исключить `toString` из списка итерации, поставив ему флаг `enumerable: false`. По стандарту, у встроенного `toString` этот флаг уже стоит.

var `user` = {

```
  
```

```
  
```

};

// помечаем toString как не подлежащий перебору в for..in

_Object_.defineProperty(_user_, "toString", {_enumerable_: false});

for(var _key_ in _user_) alert(_key_);  // name

Обратим внимание, вызов `defineProperty` не перезаписал свойство, а просто модифицировал настройки у существующего `toString`.

[Свойство-функция](https://learn.javascript.ru/descriptors-getters-setters#svoystvo-funktsiya)

Дескриптор позволяет задать свойство, которое на самом деле работает как функция. Для этого в нём нужно указать эту функцию в `get`.

Например, у объекта `user` есть обычные свойства: имя `firstName` и фамилия `surname`.

Создадим свойство `fullName`, которое на самом деле является функцией:

var `user` = {

```
  firstName
```

```
  surname
```

}

```
Object
```

```
  
```

```
    
```

```
  
```

});

alert(_user_._fullName_); // Вася Петров

Обратим внимание, снаружи `fullName` – это обычное свойство `user.fullName`. Но дескриптор указывает, что на самом деле его значение возвращается функцией.

Также можно указать функцию, которая используется для записи значения, при помощи дескриптора `set`.

Например, добавим возможность присвоения `user.fullName` к примеру выше:

var `user` = {

```
  firstName
```

```
  surname
```

}

```
Object
```

```
  
```

```
    
```

```
  
```

  set: function(value) {

      var _split_ = _value_.split(' ');

      this._firstName_ = _split_[0];

      this._surname_ = _split_[1];

    }

});

_user_._fullName_ = "Петя Иванов";

alert( `user`.`firstName` ); // Петя

alert( `user`.`surname` ); // Иванов

[Указание get/set в литералах](https://learn.javascript.ru/descriptors-getters-setters#ukazanie-get-set-v-literalah)

Если мы создаём объект при помощи синтаксиса `{ ... }`, то задать свойства-функции можно прямо в его определении.

Для этого используется особый синтаксис: `get свойство` или `set свойство`.

Например, ниже объявлен геттер-сеттер `fullName`:

var `user` = {

```
  firstName
```

```
  surname
```

  get fullName() {

```
    
```

```
  
```

  set fullName(value) {

```
    
```

```
    
```

```
    
```

```
  
```

};

alert( _user_._fullName_ ); // Вася Петров (из геттера)

_user_._fullName_ = "Петя Иванов";

alert( _user_._firstName_ ); // Петя  (поставил сеттер)

alert( _user_._surname_ ); // Иванов (поставил сеттер)

[Да здравствуют get/set!](https://learn.javascript.ru/descriptors-getters-setters#da-zdravstvuyut-get-set)

Казалось бы, зачем нам назначать get/set для свойства через всякие хитрые вызовы, когда можно сделать просто функции с самого начала? Например, `getFullName`, `setFullName`…

Конечно, в ряде случаев свойства выглядят короче, такое решение просто может быть красивым. Но основной бонус – это гибкость, возможность получить контроль над свойством в любой момент!

Например, в начале разработки мы используем обычные свойства, например у `User` будет имя `name` и возраст `age`:

function User(name, age) {

```
  
```

```
  
```

}

var `pete` = new User("Петя", 25);

alert( `pete`.`age` ); // 25

С обычными свойствами в коде меньше букв, они удобны, причины использовать функции пока нет.

…Но рано или поздно могут произойти изменения. Например, в `User` может стать более целесообразно вместо возраста `age` хранить дату рождения `birthday`:

function User(name, birthday) {

```
  
```

```
  
```

}

var `pete` = new User("Петя", new Date(1987, 6, 1));

Что теперь делать со старым кодом, который выводит свойство `age`?

Можно, конечно, найти все места и поправить их, но это долго, а иногда и невозможно, скажем, если вы взаимодействуете со сторонней библиотекой, код в которой – чужой и влезать в него нежелательно.

Добавление `get`-функции `age` позволяет обойти проблему легко и непринуждённо:

function User(name, birthday) {

```
  
```

```
  
```

  // age будет высчитывать возраст по birthday

  _Object_.defineProperty(this, "age", {

    get: function() {

      var _today_ = new Date();

      var _yearDelta_ = _today_.getFullYear() - this._birthday_.getFullYear();

      if (_today_.getMonth() > this._birthday_.getMonth() ||

        (_today_.getMonth() === this._birthday_.getMonth() && _today_.getDate() >= this._birthday_.getDate())) {

        return _yearDelta_;

      }

      return _yearDelta_ - 1;

    }

  });

}

var `pete` = new User("Петя", new Date(1987, 6, 1));

alert( `pete`.`birthday` ); // и дата рождения доступна

alert( `pete`.`age` );      // и возраст

Заметим, что `pete.age` снаружи как было свойством, так и осталось. То есть, переписывать внешний код на вызов функции `pete.age()` не нужно.

Таким образом, `defineProperty` позволяет нам начать с обычных свойств, а в будущем, при необходимости, можно в любой момент заменить их на функции, реализующие более сложную логику.

[Другие методы работы со свойствами](https://learn.javascript.ru/descriptors-getters-setters#drugie-metody-raboty-so-svoystvami)

[**Object.defineProperties(obj, descriptors)**](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/defineProperties)

Позволяет объявить несколько свойств сразу:

var `user` = {}

```
Object
```

  _firstName_: {

```
    value
```

```
  
```

  _surname_: {

```
    value
```

```
  
```

  _fullName_: {

```
    
```

```
      
```

```
    
```

```
  
```

});

alert( `user`.`fullName` ); // Петя Иванов

[**Object.keys(obj)**](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys)**,** [**Object.getOwnPropertyNames(obj)**](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames)

Возвращают массив – список свойств объекта.

`Object.keys` возвращает только `enumerable`-свойства.

`Object.getOwnPropertyNames` – возвращает все:

var `obj` = {

```
  a
```

```
  b
```

```
  internal
```

};

```
Object
```

```
  enumerable
```

});

alert( _Object_.keys(_obj_) ); // a,b

alert( _Object_.getOwnPropertyNames(_obj_) ); // a, b, internal

[**Object.getOwnPropertyDescriptor(obj, prop)**](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor)

Возвращает дескриптор для свойства `obj[prop]`.

Полученный дескриптор можно изменить и использовать `defineProperty` для сохранения изменений, например:

var `obj` = {

```
  test
```

};

var _descriptor_ = _Object_.getOwnPropertyDescriptor(_obj_, 'test');

// заменим value на геттер, для этого...

delete `descriptor`.`value`; // ..нужно убрать value/writable

delete `descriptor`.`writable`;

```
descriptor
```

```
  
```

};

// поставим новое свойство вместо старого

// если не удалить - defineProperty объединит старый дескриптор с новым

delete `obj`.`test`;

```
Object
```

```
obj
```

…И несколько методов, которые используются очень редко:

[**Object.preventExtensions(obj)**](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions)

Запрещает добавление свойств в объект.

[**Object.seal(obj)**](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/seal)

Запрещает добавление и удаление свойств, все текущие свойства делает `configurable: false`.

[**Object.freeze(obj)**](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/freeze)

Запрещает добавление, удаление и изменение свойств, все текущие свойства делает `configurable: false, writable: false`.

[**Object.isExtensible(obj)**](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/isExtensible)

Возвращает `false`, если добавление свойств объекта было запрещено вызовом метода `Object.preventExtensions`.

[**Object.isSealed(obj)**](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/isSealed)

Возвращает `true`, если добавление и удаление свойств объекта запрещено, и все текущие свойства являются `configurable: false`.

[**Object.isFrozen(obj)**](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/isFrozen)

Возвращает `true`, если добавление, удаление и изменение свойств объекта запрещено, и все текущие свойства являются `configurable: false, writable: false`.
