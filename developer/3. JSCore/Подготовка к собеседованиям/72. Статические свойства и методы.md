# 72. Статические свойства и методы

Мы также можем присвоить метод самому классу. Такие методы называются _статическими_.

В объявление класса они добавляются с помощью ключевого слова `static`, например:

class User {

  static staticMethod() {

```
    
```

```
  
```

}

```
User
```

Это фактически то же самое, что присвоить метод напрямую как свойство функции:

class User { }

```
User
```

```
  
```

};

Значением `this` при вызове `User.staticMethod()` является сам конструктор класса `User` (правило «объект до точки»).

Обычно статические методы используются для реализации функций, принадлежащих классу целиком, вообще, и при этом не относящимся к каким-то отдельным объектам.

Звучит не очень понятно? Сейчас все встанет на свои места.

Например, есть объекты статей `Article`, и нужна функция для их сравнения.

Естественное решение – сделать для этого статический метод `Article.compare`:

class Article {

```
  
```

```
    
```

```
    
```

```
  
```

  static compare(articleA, articleB) {

    return _articleA_._date_ - _articleB_._date_;

  }

}

// использование

let `articles` = [

```
  
```

```
  
```

```
  
```

];

_articles_.sort(_Article_._compare_);

alert( `articles`[0].`title` ); // CSS

Здесь метод `Article.compare` стоит «над» статьями, как средство для их сравнения. Это метод не отдельной статьи, а всего класса.

Другим примером может быть так называемый «фабричный» метод.

Скажем, нам нужно несколько способов создания статьи:

1.      Создание через заданные параметры (`title`, `date` и т. д.).

2.      Создание пустой статьи с сегодняшней датой.

3.      …или как-то ещё.

Первый способ может быть реализован через конструктор. А для второго можно использовать статический метод класса.

Такой как `Article.createTodays()` в следующем примере:

class Article {

```
  
```

```
    
```

```
    
```

```
  
```

  static createTodays() {

    // помним, что this = Article

    return new this("Сегодняшний дайджест", new Date());

  }

}

let `article` = `Article`.createTodays();

alert( `article`.`title` ); // Сегодняшний дайджест

Теперь каждый раз, когда нам нужно создать сегодняшний дайджест, нужно вызывать `Article.createTodays()`. Ещё раз, это не метод одной статьи, а метод всего класса.

Статические методы также используются в классах, относящихся к базам данных, для поиска/сохранения/удаления вхождений в базу данных, например:

// предположим, что Article - это специальный класс для управления статьями

// статический метод для удаления статьи по id:

```
Article
```

**Статические методы недоступны для отдельных объектов**

Статические методы могут вызываться для классов, но не для отдельных объектов.

Например. такой код не будет работать:

// ...

```
article
```

[Статические свойства](https://learn.javascript.ru/static-properties-methods#staticheskie-svoystva)

**Новая возможность**

Эта возможность была добавлена в язык недавно. Примеры работают в последнем Chrome.

Статические свойства также возможны, они выглядят как свойства класса, но с `static` в начале:

class Article {

```
  
```

}

alert( `Article`.`publisher` ); // Илья Кантор

Это то же самое, что и прямое присваивание `Article`:

```
Article
```

[Наследование статических свойств и методов](https://learn.javascript.ru/static-properties-methods#statics-and-inheritance)

Статические свойства и методы наследуются.

Например, метод `Animal.compare` в коде ниже наследуется и доступен как `Rabbit.compare`:

class Animal {

```
  
```

```
    
```

```
    
```

```
  
```

```
  
```

```
    
```

```
    
```

```
  
```

  static compare(animalA, animalB) {

    return _animalA_._speed_ - _animalB_._speed_;

  }

}

// Наследует от Animal

class Rabbit extends Animal {

```
  
```

```
    
```

```
  
```

}

let `rabbits` = [

```
  
```

```
  
```

];

_rabbits_.sort(_Rabbit_._compare_);

```
rabbits
```

Мы можем вызвать `Rabbit.compare`, при этом будет вызван унаследованный `Animal.compare`.

Как это работает? Снова с использованием прототипов. Как вы уже могли предположить, `extends` даёт `Rabbit` ссылку `[[Prototype]]` на `Animal`.

Так что `Rabbit extends Animal` создаёт две ссылки на прототип:

1.      Функция `Rabbit` прототипно наследует от функции `Animal`.

2.      `Rabbit.prototype` прототипно наследует от `Animal.prototype`.

В результате наследование работает как для обычных, так и для статических методов.

Давайте это проверим кодом:

class Animal {}

class Rabbit extends Animal {}

// для статики

alert(`Rabbit`.`__proto__` === `Animal`); // true

// для обычных методов

alert(Rabbit.`prototype`.`__proto__` === Animal.`prototype`); // true

[Итого](https://learn.javascript.ru/static-properties-methods#itogo)

Статические методы используются для функциональности, принадлежат классу «в целом», а не относятся к конкретному объекту класса.

Например, метод для сравнения двух статей `Article.compare(article1, article2)` или фабричный метод `Article.createTodays()`.

В объявлении класса они помечаются ключевым словом `static`.

Статические свойства используются в тех случаях, когда мы хотели бы сохранить данные на уровне класса, а не какого-то одного объекта.

Синтаксис:

class MyClass {

```
  
```

```
  
```

```
    
```

```
  
```

}

Технически, статическое объявление – это то же самое, что и присвоение классу:

```
MyClass
```

```
MyClass
```

Статические свойства и методы наследуются.

Для `class B extends A` прототип класса `B` указывает на `A`: `B.[[Prototype]] = A`. Таким образом, если поле не найдено в `B`, поиск продолжается в `A`.
