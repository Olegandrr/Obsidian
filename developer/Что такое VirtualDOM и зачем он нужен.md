![Что такое Virtual DOM? Как он работает с React?](https://youtu.be/7TvS0iKR3_c?t=740)

#### Ответ

Подробнее: [Что такое VirtualDOM](https://habr.com/ru/post/256965/)

Virtual DOM - легковесный JavaScript объект, который представляет копию реального DOM дерева. Нужен для оптимизации взаимодействия с DOM

Самой затратной по ресурсам операцией в JS является взаимодействие с DOM деревом (documentQurySelector/all, getElemenbyId). Нам нужно некоторое время для получения доступа к элементу в DOM дереве. И когда у нас много взаимодействий, приложение может тормозить. Когда происходят какие либо изменения в React то изменения вносились в Virtual DOM, и после этого мы сравнивали Virtual DOM с обычным DOM, и вносили изменения только в тех местах, где они различались


##### Краткие выводы

#VirtualDOM — это техника и набор библиотек / алгоритмов, которые позволяют нам улучшить производительность на клиентской стороне, избегая прямой работы с DOM путем взаимодействия с легким JavaScript-объектом, имитирующем DOM-дерево.  

#VirtualDOM копирует реальный #DOM . При изменении какого-либо элемента происходит сравнение измененного виртуального DOM-дерева с этой виртуальной копией, определяется разница и запускается перерисовка того, что было изменено, вносится изменение в реальный #DOM .

> **Когда данные изменяются и нуждается в обновлении (ререндеренге)?**

Когда изменяются #state, #React решает нужно ли обновление #DOM, сравнивая возвращённый элемент с ранее отрендеренным. Если они не равны, React обновит DOM.

Есть такое понятие как первичный рендеринг (монтирование) и повторный ререндеринг.
На этапе монтирования создается наша виртуальная копия DOM, а ререндеринг в следствии изменения обьекта.

#props можно обновить в родительском компоненте, а так они readonly .
#state можно изменять
#key изменение

>> **Алгоритм сравнения (согласования)**
_React сравнивает деревья начиная с их корневых элементов и направляется вниз. 

Таким образом, сравниваются

>>  **Типы (теги) корневых элементов.**
_Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля_

>> **DOM-элементы одного типа**
_При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты.

```
<div className="before" title="stuff" />

<div className="after" title="stuff" />
```

_Сравнивая эти элементы, React знает, что нужно модифицировать только `className` у DOM-узла.

>> **Компоненты одного типа**

_Когда компонент обновляется, его экземпляр остаётся прежним, поэтому его состояние сохраняется между рендерами. React обновляет пропсы базового экземпляра компонента для соответствия новому элементу и вызывает апдейт на базовом экземпляре.

_Далее вызывается метод `render()` и алгоритм сравнения рекурсивно обходит предыдущий и новый результаты._

>> **Рекурсия по дочерним элементам**

_По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React одновременно проходит по обоим спискам потомков и создаёт мутацию, когда находит отличие._

_Например, при добавлении элемента в конец дочерних элементов, преобразование между этими деревьями работает отлично:_

```
<ul>
  <li>первый</li>
  <li>второй</li>
</ul>

<ul>
  <li>первый</li>
  <li>второй</li>
  <li>третий</li>
</ul>
```

_React сравнит два дерева `<li>первый</li>`, сравнит два дерева `<li>второй</li>`, а затем вставит дерево `<li>третий</li>`._

-->

_При вставке элемента в начало, прямолинейная реализация такого алгоритма будет работать не эффективно. Например, преобразование между этими деревьями работает плохо:_

```
<ul>
  <li>Санкт-Петербург</li>
  <li>Москва</li>
</ul>

<ul>
  <li>Ростов-на-Дону</li>
  <li>Санкт-Петербург</li>
  <li>Москва</li>
</ul>
```

_React, вместо того чтобы оставить `<li>Санкт-Петербург</li>`  и `<li>Москва</li>` нетронутыми, будет мутировать каждого потомка. Эта неэффективность может стать проблемой._

_Для решения этой проблемы React поддерживает атрибут `key`. Когда у дочерних элементов есть ключи, React воспользуется ими, чтобы сопоставить потомков исходного дерева с потомками последующего дерева. 
Например, если добавить `key` к неэффективному примеру выше, преобразование дерева станет эффективнее:_

```
<ul>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>

<ul>
  <li key="2014">Ростов-на-Дону</li>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>
```

Теперь React знает, что элемент с ключом `'2014'` — новый, а элементы с ключами `'2015'` и `'2016'` переместились.

На практике найти ключ обычно несложно. Элемент, который вы хотите отобразить, уже может иметь уникальный идентификатор, и ключ может быть взят из ваших данных:

```
<li key={item.id}>{item.name}</li>
```

Когда уникальное значение отсутствует, вы можете добавить новое свойство идентификатора в вашу модель или прохешировать данные, чтобы сгенерировать ключ. Ключ должен быть уникальным только среди его соседей, а не глобально.

Важно помнить, что алгоритм согласования — это деталь реализации. 
React может повторно рендерить всё приложение на каждое действие, конечный результат будет тем же. Для ясности, повторный рендер в этом контексте означает вызов функции `render` для всех компонентов, но это не означает, что React размонтирует и смонтирует их заново. Он лишь применит различия следуя правилам, которые были обозначены выше.

##### Что такое #DOM и отличие от #VirtualDOM 

#VirtualDOM  - то, почему #React обьект работает так быстро, легковесные обьекты.

Главная проблема #DOM — он никогда не был рассчитан для создания динамического пользовательского интерфейса ( #UI ). Мы можем работать с ним, используя JavaScript и библиотеки наподобие jQuery, но их использование не решает проблем с производительностью.

Можем ли мы решить эту проблему? Похоже, что можем.

#VirtualDOM не является стандартом и в конечном итоге мы по-прежнему взаимодействуем с DOM, но делаем это как можно реже и более эффективно.
Вместо того, чтобы взаимодействовать с DOM напрямую, мы работаем с его легковесной копией. Мы можем вносить изменения в копию, исходя из наших потребностей, а после этого применять изменения к реальному DOM.  

При этом происходит сравнение DOM-дерева с его виртуальной копией, определяется разница и запускается перерисовка того, что было изменено.  
  
Такой подход работает быстрее, потому как не включает в себя все тяжеловесные части реального DOM.  

Но только если мы делаем это правильно. 
Есть две проблемы: когда именно делать повторную перерисовку DOM и как это сделать эффективно.

**Когда?**  
Когда данные изменяются и нуждается в обновлении.  
Есть два варианта узнать, что данные изменились:  

-   Первый из них — «dirty checking» (грязная проверка) заключается в том, чтобы опрашивать данные через регулярные промежутки времени и рекурсивно проверять все значения в структуре данных.
-   Второй вариант — «observable» (наблюдаемый) заключается в наблюдении за изменением состояния. Если ничего не изменилось, мы ничего не делаем. Если изменилось, мы точно знаем, что нужно обновить.

**Как?**  
Что делает этот подход действительно быстрым:  

-   Эффективные алгоритмы сравнения
-   Группировка операций чтения/записи при работе с DOM
-   Эффективное обновление только под-деревьев

Как вы понимаете, это не так просто и реализация может оказаться довольно сложной, но есть некоторые библиотеки, которые помогают реализовать этот подход в наших проектах.  
Одной из таких самых известных библиотек является React от команды разработчиков Facebook.  
  
____
#react

____

#### [[004 React + Redux|Назад]]