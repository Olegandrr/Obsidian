[[Что такое VirtualDOM и зачем он нужен]]
[[Что такое 1React]]

[[Как добавить React на страницу]]
[[4. Что такое JSX  Можем ли мы использовать React без JSX]]
[[5. JSX, условный рендеринг, работа с коллекциями]]
[[6. Зачем нужен key]]
[[7. Какие различия между компонентом-классом и функциональным компонентом]]

[[8. Что такое children в props]]

#### 9. Что делает #setState? Функция setState первым аргументом может принять объект, а может функцию. Зачем нужна функция?  
Подробнее: [[1.4.3 State - состояние компонента]] , 

В #State хранится состояние (свойства) #React элемента, его можно инициализировать в конструкторе или в теле класса.

Одно из самых важных аспектов #React заключается в том, чтобы обновить state используют #setState()

Функция #setState может принимать в виде аргумента функцию, этот аргумент - текущий state.

~~~
this.setState( (state)  => {
	return {
		count: state.count 1}
});
~~~

Происходит асинхронное обновление состояния state в зависимости от предыдущего значения.

#### 10. Как выполнить действие с новым состоянием стейта после #setState?  

##### Как использовать setState

Метод `setState()` планирует изменение объекта состояния (`state`) компонента. Когда состояние меняется, компонент рендерится повторно.

Используя новые состояния #State можно добавлять , удалять и обновлять элементы.

// Удалить элемент
~~~
setState() {
	...
	newArr = […oldArr.slice(0, idx), …oldArr.slice(idx 1)]
	...
}
~~~

// Добавить элемент
~~~
setState() {

	const newArr = [... oldArr , newItem] // добавить элемент в конец массива
	
	const newArr = [newItem, ...oldArr] // добавить элемент в начало массива

}

arr.push () - тоже изменение массива (нельзя выполнять на массивах из #State )
~~~

##### Подробнее про setState

```
setState(updater[, callback])
```
`setState()` добавляет в очередь изменения в состоянии компонента. Также он указывает React, что компонент и его дочерние элементы должны быть повторно отрендерены с обновлённым состоянием. Этот метод используется для обновления интерфейса в ответ на обработчики событий и ответы сервера.

Думайте о `setState()`, как о _запросе_, а не как о команде немедленного обновления компонента. Для увеличения производительности React может задержать его выполнение, а затем обновить несколько компонентов за один проход. In the rare case that you need to force the DOM update to be applied synchronously, you may wrap it in [`flushSync`](https://ru.reactjs.org/docs/react-dom.html#flushsync), but this may hurt performance.

Метод `setState()` не всегда обновляет компонент сразу. Он может группировать или откладывать обновление до следующего раза. Это делает чтение `this.state` сразу после вызова `setState()` потенциальной ловушкой. Вместо этого используйте `componentDidUpdate()` или колбэк `setState()` (`setState(updater, callback)`), каждый из которых гарантированно вызывается после того как было применено обновление. Если вам нужно обновить состояние на основе предыдущего, используйте аргумент `updater`, описанный ниже.

`setState()` всегда приводит к повторному рендеру, если только `shouldComponentUpdate()` не возвращает `false`. Если используются мутабельные объекты, и условие рендеринга не может быть реализовано в `shouldComponentUpdate()`, вызывайте `setState()` только при разнице следующего и предыдущего состояния. Это предотвратит ненужные повторные рендеры.

Первым аргументом передаётся функция `updater`, которая имеет следующий вид:

```
(state, props) => stateChange
```

`state` — ссылка на состояние компонента при изменении. Объект состояния не должен мутировать. Изменения должны проявляться в виде нового объекта на основе входных данных из `state` и `props`. Предположим, что мы хотели бы увеличить значение состояния с помощью `props.step`:

```
this.setState((state, props) => {
  return {counter: state.counter + props.step};
});
```

Как `state`, так и `props`, полученные функцией обновления, гарантированно будут обновлены. Результат функции поверхностно объединяется с `state`.

Второй параметр в `setState()` — необязательный колбэк, вызываемый после выполнения `setState` и повторного рендера компонента. Вместо этого в большинстве случаев для такой логики мы рекомендуем использовать `componentDidUpdate()`.

В качестве первого аргумента `setState()`, вместо функции, вы можете передать объект:

```
setState(stateChange[, callback])
```

В нём образуется новое состояние после поверхностного объединения с `stateChange`. Например, установим количество товаров в корзине:

```
this.setState({quantity: 2})
```

Эта форма записи `setState()` также асинхронна, и несколько вызовов в течение одного цикла могут быть объединены вместе. Например, вам нужно увеличить количество элементов несколько раз в одном цикле. Результат этого можно представить так:

```
Object.assign(
  previousState,
  {quantity: state.quantity + 1},
  {quantity: state.quantity + 1},
  ...
)
```

Последующие вызовы будут переопределять значения из предыдущих вызовов того же цикла. Из-за этого количество увеличится только один раз. В случае, если следующее состояние зависит от текущего, мы рекомендуем использовать форму функции обновления:

```
this.setState((state) => {
  return {quantity: state.quantity + 1};
});
```

##### React.Component
Подробнее: [React.Component](https://ru.reactjs.org/docs/react-component.html)

В качестве первого аргумента `setState()`, вместо функции, вы можете передать объект:

```
setState(stateChange[, callback])
```

В нём образуется новое состояние после поверхностного объединения с `stateChange`. Например, установим количество товаров в корзине:

```
this.setState({quantity: 2})
```

Эта форма записи `setState()` также асинхронна, и несколько вызовов в течение одного цикла могут быть объединены вместе. Например, вам нужно увеличить количество элементов несколько раз в одном цикле. Результат этого можно представить так:

```
Object.assign(
  previousState,
  {quantity: state.quantity + 1},
  {quantity: state.quantity + 1},
  ...
)
```

Последующие вызовы будут переопределять значения из предыдущих вызовов того же цикла. Из-за этого количество увеличится только один раз. В случае, если следующее состояние зависит от текущего, мы рекомендуем использовать форму функции обновления:

```
this.setState((state) => {
  return {quantity: state.quantity + 1};
});
```

Для более подробной информации смотрите:

-   [Руководство по состоянию и жизненному циклу](https://ru.reactjs.org/docs/state-and-lifecycle.html)
-   [Продвинутый уровень: когда и почему группируются вызовы `setState()`?](https://stackoverflow.com/a/48610973/458193)
-   [Продвинутый уровень: почему `this.state` не обновляется сразу?](https://github.com/facebook/react/issues/11527#issuecomment-360199710)

---

##### Какая разница между `state` и `props`?

[`props`](https://ru.reactjs.org/docs/components-and-props.html) (намеренно сокращённо от англ. «properties» — свойства) и [`state`](https://ru.reactjs.org/docs/state-and-lifecycle.html) — это обычные JavaScript-объекты. Несмотря на то, что оба содержат информацию, которая влияет на то, что увидим после рендера, есть существенное различие: `props` передаётся _в_ компонент (служат как параметры функции), в то время как `state` находится _внутри_ компонента (по аналогии с переменными, которые объявлены внутри функции).

#### 11. Что такое контроллируемый компонент?  
Подробнее: [Контролируемый и неконтролируемый компонент](https://habr.com/ru/post/502034/)

##### Краткое описание

Компонент становится контролируемым, когда вы устанавливаете его значение используя props. 

**Пример**
Например, у меня есть функция добавления задачи onSubmit ,
в ней есть preventDefault и функция очищение формы через setState с пустой " " по факту ввода значения .
setState изменяет состояние а #react понимает что нужно выполнить функцию render и надо выполнить фунцию value и её выполнение не приводит к событию.

На onSubmit - это функция добавления задачи и её очищения после ввода. На изменение **input** мы вешаем обработчик клика, который при каждом новом вводе сет-стейтит новое значение value, полученное из **event**-объекта ;

А при каждой отрисовке значение инпута берется из стейта. Выходит что инпут буквально находится под контролем у стейта — отправляет новые значения в него и читает оттуда же.

##### Подробнее [Контролируемые компоненты](https://makeweb.me/anatomiya-react-dlya-nachinayushhih-urok-9-spiski-i-formy-ne-kontroliruemye-komponenty/)

Компонент становится контролируемым, когда вы устанавливаете его значение используя props. Вот и всё.  

  ![[Pasted image 20230320183637.png]]

onChange() - обновляет state, а state обновляется value элемента.

Давайте посмотрим на пример кода.

```
import React, { Component } from 'react';

class App extends Component {
    state = {
        message: ''
    }
    updateMessage = (newText) => {
        console.log(newText);
        this.setState(() => ({
            message: newText
        }));
    }
    render() {
        return (
            <div classname="App">
                <div classname="container">
                    <input type="text" placeholder="Your message here.." value="{this.state.message}" onchange="{(event)" ==""> this.updateMessage(event.target.value)}
                    />
                    <p>the message is: {this.state.message}</p>
                </div>
            </div>
        );
    }
}

export default App;
```

Если мы посмотрим на код для этого компонента, в строке 4 мы создаем объект состояния. Он содержит единственное свойство, которое называется `message`. Здесь хранится значение, введенное в текстовое поле.

Чтобы сохранить значение, нам нужно событие, которое будет запущено, когда пользователь вводит текст в поле. Как мы это делаем?

Если вы посмотрите на строки 19 и 20 кода, вы увидите, что:

1.  Текстовое поле имеет атрибут value, связанный со свойством сообщения в состоянии.
2.  У нас есть обработчик события `onChange`.

Эти 2 пункта говорят вам, что это контролируемый компонент.

Нам не нужен элемент формы на странице, чтобы компонент был контролируемым компонентом.

Когда вносятся изменения в любой из элементов ввода, имеющих обработчик события, он запускается.

Обработчик вызывает `setState()`, как вы можете видеть в строке 9 выше. Это обновляет состояние внутри компонента.

Вы никогда не должны устанавливать состояние прямо так:

```
this.state.message = 'dont update state like this';
```

Обновление состояния таким способом не вызовет повторную визуализацию компонента, а сделанные пользователем изменения не будут отображаться в пользовательском интерфейсе.

Когда обновление состояния происходит через `setState()`, это вызывает повторную визуализацию компонента, и вновь введенное значение отображается в элементе.

Поток данных является однонаправленным от состояния компонента к элементу ввода.

Работа с контролируемыми компонентами может быть немного громоздкой. Если на странице имеется большое количество элементов ввода, каждый элемент требует настройки с атрибутом значения и обработчиком события.

#### 12. Зачем нужны #eslint и #prettier?  

#ESLint необходим для подсветки ошибок и работы с описанными правилами. 
#Prettier служит для чтения правил и форматирования кода .

-   eslint – главный модуль линтера.
-   eslint-config-airbnb  – готовая конфигурация для использования стайлгайда Airbnb.
-   eslint-config-prettier  – позволяет ESLint и Prettier работать вместе.
-   eslint-plugin-import – предназначен для поддержки синтаксиса импорта/экспорта и управления путями к файлам. Подробнее можно прочитать в [документации плагина](https://github.com/benmosher/eslint-plugin-import).
-   eslint-plugin-jsx-a11y 
-   eslint-plugin-react  – добавляет специфические настройки линтинга для проектов React.
-   eslint-plugin-react-hooks
-   husky _дает возможность зацепиться за хуки git. Это значит, что вы можете выполнять некоторые действия перед тем, как изменения будут закоммичены и отправлены в удаленный репозиторий_ .
-   lint-staged  _позволяет запускать тесты/форматеры на измененных файлах в pre-commit-хуке_

1.  `lint` - проверяет все файлы на ошибки
2.  `lint:fix` - проверяет и исправляет те ошибки, которые может
3.  `format` - форматирует все файлы с помощью prettier

#### 13. Как работать с формами в react?
Подробнее: [[1.4.12 Работа с формами]]

Используем:
#onChange() чтобы получать текущее значение;
#onSubmit() - событие "отправки" формы;
e.preventDefault() - чтобы страница не перезагружалась.

HTML-элемент `<textarea>` в качестве текста отображает дочерний элемент:

```
<textarea>
  Привет! Тут просто немного текста внутри тега textarea
</textarea>
```

В HTML `<select>` создаёт выпадающий список. HTML-код в этом примере создаёт выпадающий список
```
<select>
  <option value="grapefruit">Грейпфрут</option>
  <option value="lime">Лайм</option>
  <option selected value="coconut">Кокос</option>
  <option value="mango">Манго</option>
</select>
```

В HTML `<input type="file">` позволяет пользователю выбрать один или несколько файлов для загрузки с устройства на сервер или управлять им через JavaScript с помощью [File API](https://developer.mozilla.org/ru/docs/Web/API/File/Using_files_from_web_applications)
```
<input type="file" />
```

#### Когда происходит ререндер состояния ?
[Подробнее про ререндер состояния](Существует 4 причины, по которым компонент подвергается ререндерингу: изменение состояния, ререндеринг родительского компонента, изменение контекста и изменение хука. Существует распространенный миф о том, что ререндеринг происходит также при изменении пропов.)

Ререндеринг происходит, когда `React` необходимо обновить приложение некоторыми данными. Обычно, это является результатом действий пользователя, получения ответа на асинхронный запрос.

Существует 4 причины, по которым компонент подвергается ререндерингу: изменение состояния, ререндеринг родительского компонента, изменение контекста и изменение хука. Существует распространенный миф о том, что ререндеринг происходит также при изменении пропов.

Компонент всегда подвергается ререндерингу при изменении его состояния. Обычно, это происходит в функции обратного вызова или в хуке `useEffect`.

_Изменения состояния влекут за собой безусловный (непредотвращаемый) ререндеринг_

![](https://habrastorage.org/r/w1560/webt/qm/9j/ag/qm9jagqd8_b5ajh_yukyjf9svuc.png)
