#### Когда происходит ререндер состояния ?
[Подробнее про ререндер состояния](Существует 4 причины, по которым компонент подвергается ререндерингу: изменение состояния, ререндеринг родительского компонента, изменение контекста и изменение хука. Существует распространенный миф о том, что ререндеринг происходит также при изменении пропов.)

Ререндеринг происходит, когда `React` необходимо обновить приложение некоторыми данными. Обычно, это является результатом действий пользователя, получения ответа на асинхронный запрос.

Существует 4 причины, по которым компонент подвергается ререндерингу: изменение состояния, ререндеринг родительского компонента, изменение контекста и изменение хука. Существует распространенный миф о том, что ререндеринг происходит также при изменении пропов.

Компонент всегда подвергается ререндерингу при изменении его состояния. Обычно, это происходит в функции обратного вызова или в хуке `useEffect`.

_Изменения состояния влекут за собой безусловный (непредотвращаемый) ререндеринг_

![](https://habrastorage.org/r/w1560/webt/qm/9j/ag/qm9jagqd8_b5ajh_yukyjf9svuc.png)


____
#react

____

#### [[004 React + Redux|Назад]]




> **Когда данные изменяются и нуждается в обновлении (ререндеренге)?**

Когда изменяются #state, #React решает нужно ли обновление #DOM, сравнивая возвращённый элемент с ранее отрендеренным. Если они не равны, React обновит DOM.

Есть такое понятие как первичный рендеринг (монтирование) и повторный ререндеринг.
На этапе монтирования создается наша виртуальная копия DOM, а ререндеринг в следствии изменения обьекта.

#props можно обновить в родительском компоненте, а так они readonly .
#state можно изменять
#key изменение

>> **Алгоритм сравнения (согласования)**
_React сравнивает деревья начиная с их корневых элементов и направляется вниз. 

Таким образом, сравниваются

>>  **Типы (теги) корневых элементов.**
_Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля_

>> **DOM-элементы одного типа**
_При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты.

```
<div className="before" title="stuff" />

<div className="after" title="stuff" />
```

_Сравнивая эти элементы, React знает, что нужно модифицировать только `className` у DOM-узла.

>> **Компоненты одного типа**

_Когда компонент обновляется, его экземпляр остаётся прежним, поэтому его состояние сохраняется между рендерами. React обновляет пропсы базового экземпляра компонента для соответствия новому элементу и вызывает апдейт на базовом экземпляре.

_Далее вызывается метод `render()` и алгоритм сравнения рекурсивно обходит предыдущий и новый результаты._

>> **Рекурсия по дочерним элементам**

_По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React одновременно проходит по обоим спискам потомков и создаёт мутацию, когда находит отличие._

_Например, при добавлении элемента в конец дочерних элементов, преобразование между этими деревьями работает отлично:_

```
<ul>
  <li>первый</li>
  <li>второй</li>
</ul>

<ul>
  <li>первый</li>
  <li>второй</li>
  <li>третий</li>
</ul>
```

_React сравнит два дерева `<li>первый</li>`, сравнит два дерева `<li>второй</li>`, а затем вставит дерево `<li>третий</li>`._

-->

_При вставке элемента в начало, прямолинейная реализация такого алгоритма будет работать не эффективно. Например, преобразование между этими деревьями работает плохо:_

```
<ul>
  <li>Санкт-Петербург</li>
  <li>Москва</li>
</ul>

<ul>
  <li>Ростов-на-Дону</li>
  <li>Санкт-Петербург</li>
  <li>Москва</li>
</ul>
```

_React, вместо того чтобы оставить `<li>Санкт-Петербург</li>`  и `<li>Москва</li>` нетронутыми, будет мутировать каждого потомка. Эта неэффективность может стать проблемой._

_Для решения этой проблемы React поддерживает атрибут `key`. Когда у дочерних элементов есть ключи, React воспользуется ими, чтобы сопоставить потомков исходного дерева с потомками последующего дерева. 
Например, если добавить `key` к неэффективному примеру выше, преобразование дерева станет эффективнее:_

```
<ul>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>

<ul>
  <li key="2014">Ростов-на-Дону</li>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>
```

Теперь React знает, что элемент с ключом `'2014'` — новый, а элементы с ключами `'2015'` и `'2016'` переместились.

На практике найти ключ обычно несложно. Элемент, который вы хотите отобразить, уже может иметь уникальный идентификатор, и ключ может быть взят из ваших данных:

```
<li key={item.id}>{item.name}</li>
```

Когда уникальное значение отсутствует, вы можете добавить новое свойство идентификатора в вашу модель или прохешировать данные, чтобы сгенерировать ключ. Ключ должен быть уникальным только среди его соседей, а не глобально.

Важно помнить, что алгоритм согласования — это деталь реализации. 
React может повторно рендерить всё приложение на каждое действие, конечный результат будет тем же. Для ясности, повторный рендер в этом контексте означает вызов функции `render` для всех компонентов, но это не означает, что React размонтирует и смонтирует их заново. Он лишь применит различия следуя правилам, которые были обозначены выше.
