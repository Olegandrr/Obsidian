### Ответ

#### Основные цели

*Хорошая архитектура React-проекта может значительно упростить разработку, улучшить производительность, повысить сопровождаемость и расширяемость проекта.* 

Основная задача любой архитектуры — сделать код понятным, поддерживаемым и тестируемым. Но если ваше приложение быстрее написать на JS без архитектур, тестирования и прочего — это вполне нормально.

Преждевременная оптимизация — корень всех (или большинства) проблем в программировании.  
  
— Дональд Кнут, «Computer Programming as an Art» (1974)

![[Pasted image 20230909124459.png|600]]

Вывод: систему дороже изменять, поэтому нужно заранее думать о том, как вы будете изменять ее в будущем.

Изначально выстроив хорошую и понятную архитектуру, в результате получаем следующие **преимущества**:  
  
- **дешевле сопровождения кода** (следовательно, меньше временных и финансовых затрат);
- **упрощение тестируемости кода** (следовательно, потребуется меньше тестировщиков и ниже потери из-за пропущенных “багов на проде”);
- **ускорение внедрения новых разработчиков в проект**.

#### Структура исходного кода

Для единообразия используется `kebab-case` для всех имен файлов, так что нам нужно беспокоиться о том, какие из них написаны заглавными буквами, а какие нет.

Все наши пакеты, независимо от папки, в которой они хранятся, имеют подпапку `src`, и, что необязательно, папку `bin`. В папках `src` пакетов, хранящихся в директориях `app` и `lib`, могут иметься некоторые из следующих подпапок:

##### Компоненты

React-приложения создаются с помощью компонентов.

```javascript
├── components
│   ├── common
│   │   └── button
│   │       ├── button.tsx
│   │       ├── button.stories.tsx
│   │       ├── button.spec.tsx
│   │       └── index.ts
│   └── signup-form
│       ├── signup-form.tsx
│       ├── signup-form.spec.tsx
│       └── index.ts
```

У нас есть папка `components`, *содержащая все компоненты, которые используются в приложении более одного раза,* поэтому мы собираемся исключить все специфические компоненты из этой папки.

Содержит папки компонентов с их кодом, переводы, модульные тесты, снимки, истории (если это применимо к конкретному компоненту).

##### Страницы

Отдельной сущности для страниц в React не существует. Они тоже являются компонентами, состоящими из других компонентов. Но в отличие от других компонентов, обычно *они очень строго привязаны (например, в определенный путь URL).*

Мы можем использовать каталог `views` (или `pages`, если хотите).

```javascript
views
├── home.tsx
├── guestbook.tsx
└── newsletter
   ├── index.ts
   ├── newsletter.tsx
   └── components
       └── newsletter-form
           ├── newsletter-form.tsx
           ├── newsletter-form.spec.tsx
           └── index.ts
```

Еще один совет - *сохранять согласованное имя между страницей и маршрутом,* примерно так:

```javascript
<Route path="/bookings">
 <Route index element={<Bookings />} />
 <Route path="create" element={<CreateBooking />} />
 <Route path=":id" element={<ViewBooking />} />
 <Route path=":id/edit" element={<EditBooking />} />
 <Route path=":id/delete" element={<DeleteBooking />} />
</Route>
```

##### Layout

`Layout` вообще не являются страницами, они больше похожи на компоненты, поэтому с ними можно обращаться так же, но лучше помещать их в папку `layouts`, так понятнее, что в этом приложении есть n лэйаутов.

```javascript
layouts
├── main.tsx
└── auth.tsx
```

##### Контексты, хуки и хранилища

Это довольно просто, и обычно, почти все разработчики придерживаются чего-то подобного:

```javascript
hooks
├── use-users.ts
└── use-click-outside.ts
contexts
├── workbench.tsx
└── authentication.tsx
```

##### Функции-помощники (хэлперы, helpers)

Сколько раз вы создавали красивую функцию `formatCurrency`, не зная, куда ее положить? Папка `helpers` придет вам на помощь.

Обычно сюда помещаются все файлы, которые используются для того, чтобы код выглядел лучше. Не важно, будет ли функция использоваться несколько раз или нет.

```javascript
helpers
├── format-currency.ts
├── uc-first.ts
└── pluck.ts
```

##### Константы

Существует много проектов, которые содержат константы в папке `utils` или `helpers`, но лучше помещать их в отдельный файл, давая пользователю хороший обзор того, что используется в качестве константы в приложении. Чаще всего в эту папку помещаются только глобальные константы, поэтому не стоит помещать сюда константу `QUERY_LIMIT`, если она используется только в одной функции для очень специфического случая.

```javascript
constants
└── index.ts
```

Кроме того, можно хранить все константы в одном файле. Нет смысла разбивать каждую константу на отдельные файлы.

```javascript
// @/constants/index.ts
export const COMPLANY_EMAIL = "example@example.com";
```

И использоваться они будут так:

```javascript
import { COMPLANY_EMAIL } from "@/constants";
```

##### Стили

Просто поместите глобальные стили в папку `styles`, и все готово.

```javascript
styles
├── index.css
├── colors.css
└── typography.css
```

Если вы используете `emotion`, `styled-components` или просто CSS Modules, поместите их в папку конкретного компонента, чтобы все было оптимально упаковано.

##### Конфигурационные файлы

Есть ли у вашего приложения файлы конфигурации, такие как Dockerfiles, Fargate Task Definitions, webpack и т.д.? Папка `config` должна быть идеальным местом для них. Помещение их в соответствующую директорию позволяет избежать загрязнения корневого каталога не относящимися к делу файлами.

##### API

99% приложений `react` имеют хотя бы один вызов `API` к внешнему источнику данных (вашему бэкенду или какому-то публичному сервису), обычно эти операции выполняются в нескольких строках кода без особых сложностей, и именно поэтому, оптимальная их организация игнорируется. Рассмотрим этот код:

```javascript
axios
 .get("https://api.service.com/bookings")
 .then((res) => setBookings(res.data))
 .catch((err) => setError(err.message));
```

Довольно просто, верно? Теперь представьте, что у вас есть эти 3 строки, распределенные по 10 компонентам, потому что вы часто используете именно этот адрес сервера.

Рассмотрите возможность использования каталога `api`, который, прежде всего, содержит экземпляр клиента, используемого для вызовов, например, `fetch` или `axios`, а также файлы, содержащие декларации вызовов `fetch`.

```javascript
api
├── client.ts
├── users.ts
└── bookings.ts
```

И пример файла users.ts:

```javascript
export type User = {
 id: string;
 firstName: string;
 lastName: string;
 email: string;
};

export const fetchUsers = () => {
 return client.get<User[]>("/users", {
   baseURL: "https://api.service.com/v3/",
 });
};
```

##### Резюме

Такая структура папок позволяет нам писать по-настоящему модульный код, так как она создаёт чёткую систему разделения ответственностей между различными концепциями, задаваемыми нашими зависимостями. Это помогает нам искать в репозитории переменные, функции и компоненты, причём, независимо от того, знает ли тот, кто их ищет, об их существовании, или нет. Более того, это помогает нам хранить в отдельных папках минимальный объём содержимого, что, в свою очередь, облегчает работу с ними.

#### URM диаграмма проекта

![[Pasted image 20230909125200.png]]

*Красные стрелки* — поток течения данных (но не зависимостей, диаграмма зависимостей отображена на круговой диаграмме выше). Изображение в виде прямоугольной диаграммы позволяет лучше понять, как движется поток данных внутри приложения. Идею описания в виде такой диаграммы я увидел в [ЭТОЙ](https://habr.com/ru/company/mobileup/blog/335382/) статье.

![[Pasted image 20230909125445.png|600]]

Исходники для увеличения — [GitHub](https://github.com/RostislavDugin/clean-architecture-react-typescript/tree/master/information).

#### Как обеспечить обязательное применение руководства по стилю?

Мы стремились к единообразию структуры файлов и папок нашего проекта. Того же самого мы хотели добиться и для кода.

В результате мы решили с нуля создать руководство по стилю и обеспечить его обязательное применение с помощью линтера. Правила, выполнение которых нельзя было обеспечить с помощью линтера, контролировались в ходе код-ревью.

Настройка линтера в монорепозитории выполняется так же, как и в любом другом репозитории. И это хорошо, так как это позволяет проверить весь репозиторий за один запуск линтера. Если вы не знакомы с линтерами — рекомендую взглянуть на [ESLint](https://eslint.org/) и [Stylelint](https://stylelint.io/). Мы пользуемся именно ими.

#### Как поддерживать качество кода на высоком уровне?

Линтеры, тесты, контроль типов — всё это благотворно сказывается на качестве кода. Но программист легко может забыть запустить соответствующие проверки перед включением кода в ветку `master`. Лучше всего сделать так, чтобы подобные проверки запускались бы автоматически. Некоторые предпочитают делать это при каждом коммите, пользуясь [хуками Git](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks), что не позволяет сделать коммит до тех пор, пока код не пройдёт все проверки. Но мы считаем, что при таком подходе система слишком сильно вмешивается в работу программиста. Ведь, например, работа над некоей веткой может занять несколько дней, и все эти дни она не будет признана подходящей для отправки в репозиторий. Поэтому мы проверяем коммиты, используя систему непрерывной интеграции. Проверкам подвергается только код веток, которые связаны с merge-запросами. Это позволяет нам избежать запуска проверок, которые гарантированно не будут пройдены, так как мы чаще всего делаем запросы на включение результатов своей работы в основной код проекта тогда, когда уверены в том, что эти результаты способны пройти все проверки.  
  
Последовательность действий, выполняемая при автоматической проверке кода, начинается с установки зависимостей. Далее идут проверка типов, запуск линтеров, выполнение модульных тестов, сборка приложения, запуск cypress-тестов. Почти все эти задачи выполняются параллельно. Если на каком-то из этих шагов произойдёт ошибка, весь процесс проверки будет признан неудавшимся и соответствующую ветку нельзя будет включить в основной код проекта. Вот пример работающей системы проверки кода.  
  
![[Pasted image 20230909132119.png]]


Подробнее: [Архитектура современного React приложения](https://it-dev-journal.ru/articles/arhitektura-sovremennogo-react-prilozheniya), [Организация разработки крупномасштабных React-приложений](https://habr.com/ru/companies/ruvds/articles/515682/) , [Структурирование React-приложений](https://habr.com/ru/companies/ruvds/articles/460793/)

____
#React #component 

____

### [[004 React + Redux|Назад]]