#### Ответ

##### Как использовать setState

Метод `setState()` планирует изменение объекта состояния (`state`) компонента. Когда состояние меняется, компонент рендерится повторно.

Используя новые состояния #State можно добавлять , удалять и обновлять элементы.

// Удалить элемент
~~~
setState() {
	...
	newArr = […oldArr.slice(0, idx), …oldArr.slice(idx 1)]
	...
}
~~~

// Добавить элемент
~~~
setState() {

	const newArr = [... oldArr , newItem] // добавить элемент в конец массива
	
	const newArr = [newItem, ...oldArr] // добавить элемент в начало массива

}

arr.push () - тоже изменение массива (нельзя выполнять на массивах из #State )
~~~

##### Подробнее про setState

```
setState(updater[, callback])
```
`setState()` добавляет в очередь изменения в состоянии компонента. Также он указывает React, что компонент и его дочерние элементы должны быть повторно отрендерены с обновлённым состоянием. Этот метод используется для обновления интерфейса в ответ на обработчики событий и ответы сервера.

Думайте о `setState()`, как о _запросе_, а не как о команде немедленного обновления компонента. Для увеличения производительности React может задержать его выполнение, а затем обновить несколько компонентов за один проход. In the rare case that you need to force the DOM update to be applied synchronously, you may wrap it in [`flushSync`](https://ru.reactjs.org/docs/react-dom.html#flushsync), but this may hurt performance.

Метод `setState()` не всегда обновляет компонент сразу. Он может группировать или откладывать обновление до следующего раза. Это делает чтение `this.state` сразу после вызова `setState()` потенциальной ловушкой. Вместо этого используйте `componentDidUpdate()` или колбэк `setState()` (`setState(updater, callback)`), каждый из которых гарантированно вызывается после того как было применено обновление. Если вам нужно обновить состояние на основе предыдущего, используйте аргумент `updater`, описанный ниже.

`setState()` всегда приводит к повторному рендеру, если только `shouldComponentUpdate()` не возвращает `false`. Если используются мутабельные объекты, и условие рендеринга не может быть реализовано в `shouldComponentUpdate()`, вызывайте `setState()` только при разнице следующего и предыдущего состояния. Это предотвратит ненужные повторные рендеры.

Первым аргументом передаётся функция `updater`, которая имеет следующий вид:

```
(state, props) => stateChange
```

`state` — ссылка на состояние компонента при изменении. Объект состояния не должен мутировать. Изменения должны проявляться в виде нового объекта на основе входных данных из `state` и `props`. Предположим, что мы хотели бы увеличить значение состояния с помощью `props.step`:

```
this.setState((state, props) => {
  return {counter: state.counter + props.step};
});
```

Как `state`, так и `props`, полученные функцией обновления, гарантированно будут обновлены. Результат функции поверхностно объединяется с `state`.

Второй параметр в `setState()` — необязательный колбэк, вызываемый после выполнения `setState` и повторного рендера компонента. Вместо этого в большинстве случаев для такой логики мы рекомендуем использовать `componentDidUpdate()`.

В качестве первого аргумента `setState()`, вместо функции, вы можете передать объект:

```
setState(stateChange[, callback])
```

В нём образуется новое состояние после поверхностного объединения с `stateChange`. Например, установим количество товаров в корзине:

```
this.setState({quantity: 2})
```

Эта форма записи `setState()` также асинхронна, и несколько вызовов в течение одного цикла могут быть объединены вместе. Например, вам нужно увеличить количество элементов несколько раз в одном цикле. Результат этого можно представить так:

```
Object.assign(
  previousState,
  {quantity: state.quantity + 1},
  {quantity: state.quantity + 1},
  ...
)
```

Последующие вызовы будут переопределять значения из предыдущих вызовов того же цикла. Из-за этого количество увеличится только один раз. В случае, если следующее состояние зависит от текущего, мы рекомендуем использовать форму функции обновления:

```
this.setState((state) => {
  return {quantity: state.quantity + 1};
});
```

##### React.Component
Подробнее: [React.Component](https://ru.reactjs.org/docs/react-component.html)

В качестве первого аргумента `setState()`, вместо функции, вы можете передать объект:

```
setState(stateChange[, callback])
```

В нём образуется новое состояние после поверхностного объединения с `stateChange`. Например, установим количество товаров в корзине:

```
this.setState({quantity: 2})
```

Эта форма записи `setState()` также асинхронна, и несколько вызовов в течение одного цикла могут быть объединены вместе. Например, вам нужно увеличить количество элементов несколько раз в одном цикле. Результат этого можно представить так:

```
Object.assign(
  previousState,
  {quantity: state.quantity + 1},
  {quantity: state.quantity + 1},
  ...
)
```

Последующие вызовы будут переопределять значения из предыдущих вызовов того же цикла. Из-за этого количество увеличится только один раз. В случае, если следующее состояние зависит от текущего, мы рекомендуем использовать форму функции обновления:

```
this.setState((state) => {
  return {quantity: state.quantity + 1};
});
```

Для более подробной информации смотрите:

-   [Руководство по состоянию и жизненному циклу](https://ru.reactjs.org/docs/state-and-lifecycle.html)
-   [Продвинутый уровень: когда и почему группируются вызовы `setState()`?](https://stackoverflow.com/a/48610973/458193)
-   [Продвинутый уровень: почему `this.state` не обновляется сразу?](https://github.com/facebook/react/issues/11527#issuecomment-360199710)

---

##### Какая разница между `state` и `props`?

[`props`](https://ru.reactjs.org/docs/components-and-props.html) (намеренно сокращённо от англ. «properties» — свойства) и [`state`](https://ru.reactjs.org/docs/state-and-lifecycle.html) — это обычные JavaScript-объекты. Несмотря на то, что оба содержат информацию, которая влияет на то, что увидим после рендера, есть существенное различие: `props` передаётся _в_ компонент (служат как параметры функции), в то время как `state` находится _внутри_ компонента (по аналогии с переменными, которые объявлены внутри функции).


____
#react

____

#### [[004 React + Redux|Назад]]