```
useDirtyState 

import "./styles.css"; 

// задача: написать кастомный хук useDirtyState
// вначале у которого возвращается isDirty = false
// а если хоть раз применен setState то isDirty = true
// + повесить setState на обработчик клика у increment

const useDirtyState = (initialValue = 0) => { 
	return [] 
}; 

export default function App() { 
	const [state, setState, isDirty] = useDirtyState(0); 
	
	return ( 
		<div className="App"> 
		<div>State: {state}</div> 
		<div>Is state dirty: {isDirty ? "dirty" : "not dirty"}</div> 
		<button>Increment</button> 
		</div> 
	); 
}
```

```
import React, { useEffect, useRef } from 'react';

function PropsLogger(props) {
  const prevProps = useRef(props);

  useEffect(() => {
    const changedProps = Object.entries(props).reduce((result, [key, value]) => {
      if (prevProps.current[key] !== value) {
        result[key] = value;
      }
      return result;
    }, {});
    console.log('Props changed:', changedProps);
    prevProps.current = props;
  }, [props]);

  return null;
}

export default PropsLogger;


В этом компоненте мы используем хук useRef, чтобы сохранить предыдущие значения пропсов. Внутри эффекта мы сравниваем текущие пропсы с предыдущими, используя метод Object.entries для перебора объекта и метод reduce для создания нового объекта с измененными пропсами. Затем мы выводим этот новый объект в консоль и обновляем значение предыдущих пропсов с помощью prevProps.current = props. Этот компонент также не рендерит никакого контента на странице, поэтому мы возвращаем null.
```

[Задача №1](https://codesandbox.io/s/react-middle-realizovat-huk-xf9fxw?file=/src/App.js)
