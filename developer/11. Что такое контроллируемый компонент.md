#### 11. Что такое контроллируемый компонент?  
Подробнее: [Контролируемый и неконтролируемый компонент](https://habr.com/ru/post/502034/)

##### Краткое описание

Компонент становится контролируемым, когда вы устанавливаете его значение используя props. 

**Пример**
Например, у меня есть функция добавления задачи onSubmit ,
в ней есть preventDefault и функция очищение формы через setState с пустой " " по факту ввода значения .
setState изменяет состояние а #react понимает что нужно выполнить функцию render и надо выполнить фунцию value и её выполнение не приводит к событию.

На onSubmit - это функция добавления задачи и её очищения после ввода. На изменение **input** мы вешаем обработчик клика, который при каждом новом вводе сет-стейтит новое значение value, полученное из **event**-объекта ;

А при каждой отрисовке значение инпута берется из стейта. Выходит что инпут буквально находится под контролем у стейта — отправляет новые значения в него и читает оттуда же.

##### Подробнее [Контролируемые компоненты](https://makeweb.me/anatomiya-react-dlya-nachinayushhih-urok-9-spiski-i-formy-ne-kontroliruemye-komponenty/)

Компонент становится контролируемым, когда вы устанавливаете его значение используя props. Вот и всё.  

  ![[Pasted image 20230320183637.png]]

onChange() - обновляет state, а state обновляется value элемента.

Давайте посмотрим на пример кода.

```
import React, { Component } from 'react';

class App extends Component {
    state = {
        message: ''
    }
    updateMessage = (newText) => {
        console.log(newText);
        this.setState(() => ({
            message: newText
        }));
    }
    render() {
        return (
            <div classname="App">
                <div classname="container">
                    <input type="text" placeholder="Your message here.." value="{this.state.message}" onchange="{(event)" ==""> this.updateMessage(event.target.value)}
                    />
                    <p>the message is: {this.state.message}</p>
                </div>
            </div>
        );
    }
}

export default App;
```

Если мы посмотрим на код для этого компонента, в строке 4 мы создаем объект состояния. Он содержит единственное свойство, которое называется `message`. Здесь хранится значение, введенное в текстовое поле.

Чтобы сохранить значение, нам нужно событие, которое будет запущено, когда пользователь вводит текст в поле. Как мы это делаем?

Если вы посмотрите на строки 19 и 20 кода, вы увидите, что:

1.  Текстовое поле имеет атрибут value, связанный со свойством сообщения в состоянии.
2.  У нас есть обработчик события `onChange`.

Эти 2 пункта говорят вам, что это контролируемый компонент.

Нам не нужен элемент формы на странице, чтобы компонент был контролируемым компонентом.

Когда вносятся изменения в любой из элементов ввода, имеющих обработчик события, он запускается.

Обработчик вызывает `setState()`, как вы можете видеть в строке 9 выше. Это обновляет состояние внутри компонента.

Вы никогда не должны устанавливать состояние прямо так:

```
this.state.message = 'dont update state like this';
```

Обновление состояния таким способом не вызовет повторную визуализацию компонента, а сделанные пользователем изменения не будут отображаться в пользовательском интерфейсе.

Когда обновление состояния происходит через `setState()`, это вызывает повторную визуализацию компонента, и вновь введенное значение отображается в элементе.

Поток данных является однонаправленным от состояния компонента к элементу ввода.

Работа с контролируемыми компонентами может быть немного громоздкой. Если на странице имеется большое количество элементов ввода, каждый элемент требует настройки с атрибутом значения и обработчиком события.