Подробнее: [Array.Prototype.reduce()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)

Метод [arr.reduce](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce) используется для вычисления какого-нибудь единого значения на основе всего массива.

##### Синтаксис:

`let value = arr.reduce(function(accumulator, item, index, array) {   // ... }, [initial]);
`
Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.

##### Аргументы:
-   `accumulator` – результат предыдущего вызова этой функции, равен `initial` при первом вызове (если передан `initial`),
-   `item` – очередной элемент массива,
-   `index` – его индекс,
-   `array` – сам массив.

##### Описание

При вызове функции результат её вызова на предыдущем элементе массива передаётся как первый аргумент.

Звучит сложновато, но всё становится проще, если думать о первом аргументе как «аккумулирующем» результат предыдущих вызовов функции. По окончании он становится результатом `reduce`.

Этот метод проще всего понять на примере.

Тут мы получим сумму всех элементов массива всего одной строкой:
~~~
let arr = [1, 2, 3, 4, 5];  
let result = arr.reduce((sum, current) => sum + current, 0);  
alert(result); // 15`
~~~

Здесь мы использовали наиболее распространённый вариант `reduce`, который использует только 2 аргумента.

Давайте детальнее разберём, как он работает.
1.  При первом запуске `sum` равен `initial` (последний аргумент `reduce`), то есть `0`, а `current` – первый элемент массива, равный `1`. Таким образом, результат функции равен `1`.
2.  При втором запуске `sum = 1`, и к нему мы добавляем второй элемент массива (`2`).
3.  При третьем запуске `sum = 3`, к которому мы добавляем следующий элемент, и так далее…

Поток вычислений получается такой:

![[Pasted image 20230119175431.png]]

Здесь отчётливо видно, как результат предыдущего вызова передаётся в первый аргумент следующего.

Мы также можем опустить начальное значение:
~~~
`let arr = [1, 2, 3, 4, 5];  // убрано начальное значение (нет 0 в конце) 
let result = arr.reduce((sum, current) => sum + current);  
alert( result ); // 15`
~~~
Результат – точно такой же! Это потому, что при отсутствии `initial` в качестве первого значения берётся первый элемент массива, а перебор стартует со второго.

Таблица вычислений будет такая же за вычетом первой строки.

Но такое использование требует крайней осторожности. 
Если массив пуст, то вызов `reduce` без начального значения выдаст ошибку.

Вот пример:
~~~
`let arr = [];  
// Error: Reduce of empty array with no initial value // если бы существовало начальное значение, reduce вернул бы его для пустого массива. 
arr.reduce((sum, current) => sum + current);`
~~~
Поэтому рекомендуется всегда указывать начальное значение.

## [[003 JSCore|Назад]]