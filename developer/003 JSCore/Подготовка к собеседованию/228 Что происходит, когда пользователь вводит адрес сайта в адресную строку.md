#### 11. Что происходит, когда пользователь вводит адрес сайта в адресную строку?
Подробнее: [[229 Что на самом деле происходит, когда пользователь вбивает в браузер адрес google.com]]

##### 1. "g" + enter

1.  При нажатии на клавишу "g" в поиске #браузер будет выполняться большоее количество кода,  рекомендации будут обновляться с каждой новой напечатанной буквой. Выполнится #автоподстановка .
2.  Нажатие клавиши "enter" до конца. 
	* В режиме #ядро происходит преобразование и обработка ввода с клавиатуры.
	* Происходит обработка адресной строки браузера.
	* #API #Windows вызывает #обработчик-событий окна и сообщения.
	* Обработчик окна ( #hWnd) взаимодействует с обработчиком сообщения ( #WM_KEYDOWN) , после чего с ними взаимодействует следующий обработчик #VK_RETURN , который поступил в #SendMessage. ОС понимает, что пользователь нажал клавишу Enter.
3. Сигнал прерывания активирует событие прерывания в драйвере I/O Kit клавиатуры. Сигнал преобразуется в код клавиатуры, а затем передаётся в #WindowServer => событие помещается в очередь. Затем события могут быть прочитаны из этой очереди потоками с достаточными привилегиями, чтобы вызывать функцию `mach_ipc_dispatch`. Чаще всего это происходит и обрабатывается с помощью основного цикла `NSApplication` через `NSEvent` в `NSEventype KeyDown`.  
4. Для получения нажатия клавиши будет использован общий драйвер событий #evdev . Графический #API окна, получившего символ, печатает соответствующий символ шрифта в нужном поле.  

##### 2. Парсинг URL

#браузер имеет информации об #URL : #HTTP и  #Resource.

1. Если пользователь не вводит #домен имя , то #браузер осуществляет поисковой запрос.
2. Браузер проверяет список «предзагруженных #HSTS (HTTP Strict Transport Security)». Это список сайтов, которые требуют, чтобы к ним обращались только по #HTTPS.
3. Если нужный сайт есть в этом списке, то браузер отправляет ему запрос через #HTTPS вместо #HTTP. В противном случае, начальный запрос посылается по HTTP. 
4. Проверка браузером имени #hosts 

##### 3. Определение DNS

1. #Браузер проверяет наличие #домен в своём #кэш.
	* Если  домен нет: браузер вызывает библиотечную функцию #gethostbyname для поиска нужного адреса.
	* Если домен не закэширован и отсутствует в файле #hosts :  `gethostbyname` отправляет запрос к сетевому #DNS-сервер
		* #домен в той же подсети: [ARP-запрос](https://ru.wikipedia.org/wiki/ARP) отправляется этому серверу.
		* #домен в другой подсети: #ARP-запрос отправляется на #IP-адрес шлюза по умолчанию.

Для того, чтобы отправить широковещательный #ARP-запрос необходимо отыскать целевой #IP-адрес, а также знать #MAC-адрес интерфейса, который будет использоваться для отправки ARP-запроса.  

ARP-запрос:  
`Sender MAC: interface:mac:address:here`  
`Sender IP: interface.ip.goes.here`  
`Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)`  
`Target IP: target.ip.goes.here`  

ARP-ответ:  
`Sender MAC: target:mac:address:here`  
`Sender IP: target.ip.goes.here`  
`Target MAC: interface:mac:address:here`  
`Target IP: interface.ip.goes.here`  

##### 4. Открытие сокета

Когда браузер получает #IP-адрес конечного сервера, то он берёт эту информацию и данные об используемом порте из #URL (80 порт для #HTTP, 443 для #HTTPS) и осуществляет вызов функции #socket системной библиотеки и запрашивает поток #TCP сокета — `AF_INET` и `SOCK_STREAM`.  

#TCP-сегмент >> Cетевой уровень ( + IP-заголовок , + IP-адрес ) >> Сформирован #пакет 

Пакет передаётся на канальный уровень >> добавляется заголовок кадра, который включает MAC-адрес сетевой карты (NIC) компьютера, а также MAC-адрес шлюза (локального роутера) >> передача через:
  
-   [Ethernet](http://en.wikipedia.org/wiki/IEEE_802.3)
-   [WiFi](https://en.wikipedia.org/wiki/IEEE_802.11)
-   [По сотовой связи](https://en.wikipedia.org/wiki/Cellular_data_communication_protocol)

###### Жизненный цикл TCP-соединения

**a. Клиент выбирает номер начальной последовательности ( #ISN) и отправляет пакет серверу с установленным битом #SYN для открытия соединения.**  
  
**b. Сервер получает пакет с битом SYN и, если готов к установлению соединения, то:**  
  
-   Выбирает собственный номер начальной последовательности;
-   Устанавливает SYN-бит, чтобы сообщить о выборе начальной последовательности;
-   Копирует ISN клиента +1 в поле ACK и добавляет ACK-флаг для обозначения подтверждения получения первого пакета.
 
**c. #Клиент подтверждает соединение путём отправки пакета:**  
  
-   Увеличивает номер своей начальной последовательности;
-   Увеличивает номер подтверждения получения;
-   Устанавливает поле ACK.

**d. Данные передаются следующим образом:**  
  
-   Когда одна сторона отправляет N байтов, то увеличивает значение поля SEQ на это число.
-   Когда вторая сторона подтверждает получение этого пакета (или цепочки пакетов), она отправляет пакет ACK, в котором значение поля ACK равняется последней полученной последовательности.

**e. Закрытие соединения:**  
  
-   Сторона, которая хочет закрыть соединение, отправляет пакет FIN;
-   Другая сторона подтверждает FIN (с помощью ACK) и отправляет собственный FIN-пакет;
-   Инициатор прекращения соединения подтверждает получение FIN отправкой собственного ACK.

##### 5. TLS handshake

1. #Клиент  сообщения  серверу #ClientHello версией протокола #TLC
2. #Сервер отвечает клиенту сообщением #ServerHello  версией протокола #TLC 
3.  Клиент подтверждает #сертификат сервера
4.  Сервер генерирует собственную копию мастер-ключа.
5.  Клиент отправляет сообщение серверу #Finished , шифруя #хеш передачи с помощью симметричного ключа.
6.  Сервер генерирует собственный #хеш , расшифровывает хеш клиента и проверяет совпадение. 
   Если совпадение обнаружено, сервер отправляет клиенту собственный ответ `Finished`, также зашифрованный симметричным ключом.
7.   #TLS-сессия передаёт данные приложения ( #HTTP), зашифрованные с помощью подтверждённого симметричного ключа.

##### 6. Протокол HTTP

#HTTPD (HTTP Daemon) является одним из инструментов обработки запросов/ответов на стороне сервера. Наиболее популярные HTTPD-серверы это #Apache или #Nginx для Linux и #IIS для Windows.  
  
HTTPD (HTTP Daemon) получает запрос.  
— Сервер разбирает запрос по следующим параметрам:  
	-   Метод HTTP-запроса ( #GET, #POST, #HEAD, #PUT или #DELETE). В случае URL-адреса, который пользователь напечатал в строке браузера, мы имеем дело с GET-запросом.
	-   Домен. В нашем случае — google.com.
	-   Запрашиваемые пути/страницы, в нашем случае — `/` (нет запрошенных путей, `/` — это путь по умолчанию).
— Сервер проверяет существование виртуального хоста, который соответствует google.com.  
— Сервер проверяет, что google.com может принимать GET-запросы.  
— Сервер проверяет, имеет ли клиент право использовать этот метод (на основе IP-адреса, аутентификации и прочее).  
— Если на сервере установлен модуль перезаписи (`mod_rewrite` для Apache или `URL Rewrite` для IIS), то он сопоставляет запрос с одним из сконфигурированных правил. Если находится совпадающее правило, то сервер использует его, чтобы переписать запрос.  
— Сервер находит контент, который соответствует запросу, в нашем случае он изучит индексный файл.  
— Далее сервер разбирает («парсит») файл с помощью обработчика. Если Google работает на PHP, то сервер использует #PHP для интерпретации индексного файла и направляет результат клиенту.  

##### 7. За кулисами браузера

#Браузер включает следующие компоненты:  
  
-   **Пользовательский интерфейс**: В него входит адресная строка, кнопки продвижения вперёд/назад, меню закладок и так далее. Сюда относятся все элементы, кроме окна, в котором собственно отображается веб-страница.
-   **« #Движок » браузера**: Распределяет действия между движком рендеринга и интерфейсом пользователя.
-   **«Движок» #рендеринг : Отвечает за отображение запрашиваемого контента. К примеру, если запрашивается HTML, то «движок» разбирает код HTML и CSS, а затем отображает полученный контент на экране.
-   **Сетевая часть**: с помощью сетевых функций браузер обрабатывает вызовы, вроде HTTP-запросов, с применением различных реализаций для разных платформ.
-   **Бэкенд интерфейса ( #UI)**: Используется для отрисовки базовых виджетов, вроде комбо-боксов и окон.
-   **Интерпретатор JS : Используется для парсинга и выполнения JavaScript-кода.
-   **Хранилище данных**: Браузеру может понадобиться локально хранить некоторые данные (например, cookie). Кроме того, браузеры поддерживают различные механизмы хранения, такие как #localStorage , #IndexedDB, #WebSQL и #FileSystem.

##### 8. Парсинг HTML

Движок #рендеринг начинает получать содержимое запрашиваемого документа от сетевого механизма браузера. Как правило, контент поступает кусками по 8Кб. Главной задачей HTML-парсера является разбор разметки в специальное #дерево.  
  
Получающееся на выходе дерево («parse tree») — это дерево #DOM-элемент и #DOM-узел атрибутов. #DOM — сокращение от `Document Object Model`. Это модель объектного представления HTML-документа и интерфейс для взаимодействия HTML-элементов с «внешним миром» (например, JavaScript-кодом). Корнем дерева является объект «Документ».  
  
###### Алгоритм разбора

HTML-нельзя «распарсить» с помощью обычных анализаторов (нисходящих или восходящих). Тому есть несколько причин:  
  
-   Прощающая почти что угодно природа языка;
-   Тот факт, что браузеры обладают известной толерантностью к ошибкам и поддерживают популярные ошибки в HTML.
-   Процесс парсинга может заходить в тупик. В других языках код, который требуется разобрать, не меняется в процессе анализа, в то время как в HTML с помощью динамического кода (например, скриптовые элементы, содержащие вызовы `document.write()`) могут добавляться дополнительные токены, в результате чего сам процесс парсинга модифицирует вывод.

Невозможность использования привычных технологий парсинга приводит к тому, что разработчики браузеров реализуют собственные механизмы разбора HTML. Алгоритм парсинга подробно описан в [спецификации HTML5](http://www.w3.org/TR/html5/).  
  
Алгоритм состоит из двух этапов: #токенизация и создания #дерево.  

###### Действия после завершения парсинга

После этого браузер начинает подгружать внешние ресурсы, связанные со страницей (стили, изображения, скрипты и так далее).  
  
На этом этапе браузер помечает документ, как интерактивный и начинает разбирать скрипты, находящиеся в «отложенном» состоянии: то есть те из них, что должны быть исполнены после парсинга. После этого статус документа устанавливается в состояние «`complete`» и инициируется событие загрузки («`load`»).  
  
Важный момент: ошибки `«Invalid Syntax»` при разборе не может быть, поскольку браузеры исправляют любой «невалидный» контент и продолжают работу.  

##### 9. Интерпретация CSS

-   Во время разбора браузер парсит CSS-файлы, содержимое тегов `<style>` и атрибутов «style» c помощью «[лексической и синтаксической грамматики CSS](http://www.w3.org/TR/CSS2/grammar.html)».
-   Каждый CSS-файл разбирается в объект `StyleSheet`, каждый из таких объектов содержит правила CSS с селекторами и объектами в соответствии с грамматикой CSS.
-   #Парсер CSS может быть как восходящим, так и нисходящим.

##### 10. #Рендеринг
###### Рендеринг страниц

-   Путём перебора DOM-узлов и вычисления для каждого узла значений CSS-стилей создаётся «Дерево рендера» (Render Tree или Frame Tree).
-   Вычисляется предпочтительная ширина каждого узла в нижней части дерева — для этого суммируются значения предпочтительной ширины дочерних узлов, а также горизонтальные поля, границы и отступы узлов.
-   Вычисляется реальная ширина каждого узла сверху-вниз (доступная ширина каждого узла выделяется его потомкам).
-   Вычисляется высота каждого узла снизу-вверх — для этого применяется перенос текста и суммируются значения полей, высоты, отступов и границ потомков.
-   Вычисляются координаты каждого узла (с использованием ранее полученной информации).
-   Если элементы плавающие или спозиционированы абсолютно или относительно, предпринимаются более сложные действия. Более подробно они описаны [здесь](http://dev.w3.org/csswg/css2/) и [здесь](http://www.w3.org/Style/CSS/current-work).
-   Создаются слои для описания того, какие части страницы можно анимировать без необходимости повторного растрирования. Каждый объект (фрейма или рендера) присваивается слою.
-   Для каждого слоя на странице выделяются текстуры.
-   Объекты (рендеры/фреймы) каждого слоя перебираются и для соответствующих слоёв выполняются команды отрисовки. Растрирование может осуществляться процессором или возможна отрисовка на графическом процессоре (GPU) через D2D/SkiaGL.
-   Все вышеперечисленные шаги могут требовать повторного использования значений, сохранённых с последнего рендеринга страницы, такая инкрементальная работа требует меньше затрат.
-   Слои страницы отправляются процессу-компоновщику, где они комбинируются со слоями для другого видимого контента (интерфейс браузера, iframe-элементы, addon-панели).
-   Вычисляются финальные позиции слоёв и через Direct3D/OpenGL отдаются композитные команды. Командные буферы GPU освобождаются для асинхронного рендеринга и фрейм отправляется для отображения на экран.

###### Рендеринг GPU

-   Во время процесса рендеринга уровни графических вычислений могут использовать процессор компьютера или графический процессор ( #GPU).
-   Во втором случае уровни графического программного обеспечения делят задачу на множество частей, что позволяет использовать параллелизм GPU для вычисления плавающей точки, которое требуется для процесса рендеринга.

###### Вызванное пользователем и пост-рендеринговое исполнение

После завершения рендеринга, браузер исполняет JavaScript-код в результате срабатывания некоего часового механизма (так работают дудлы на странице Google) или в результате действий пользователя (ввод поискового запроса в строку и получение рекомендаций в ответ). Также могут срабатывать плагины вроде #Flash или #Java (но не в рассматриваемом примере с домашней страницей Google). Скрипты могут потребовать обработки дополнительных сетевых запросов, изменять страницу или её шаблон, что приведёт к следующему этапу рендеринга и отрисовки.
\




