#### 14. Как обрабатывать ошибки в async/await?

Когда промис завершается успешно, `await promise` возвращает результат. 
Когда завершается с ошибкой – будет выброшено #исключение. Как если бы на этом месте находилось выражение `throw`.

Такой код:
~~~
async function f() {   
	await Promise.reject(new Error("Упс!"));_ }`
~~~
Делает то же самое, что и такой:
~~~
`async function f() {   
	throw new Error("Упс!");_ }`
~~~
Но есть отличие: на практике промис может завершиться с ошибкой не сразу, а через некоторое время. В этом случае будет задержка, а затем `await` выбросит исключение.

Такие ошибки можно ловить, используя `try..catch`, как с обычным `throw`:
~~~
async function f() {    
	try {     
		let response = await fetch('http://no-such-url');   
	} catch(err) {     _
		alert(err); // TypeError: failed to fetch_   } }  f();`
~~~
В случае ошибки выполнение `try` прерывается и управление прыгает в начало блока `catch`. Блоком `try` можно обернуть несколько строк:
~~~
async function f() {    
	try {     
		let response = await fetch('/no-user-here');     
		let user = await response.json();   
	} catch(err) {     // перехватит любую ошибку в блоке try: и в fetch, и в response.json     
	alert(err);   } }  f();`
~~~
Если у нас нет `try..catch`, асинхронная функция будет возвращать завершившийся с ошибкой промис (в состоянии `rejected`). В этом случае мы можем использовать метод `.catch` промиса, чтобы обработать ошибку:
~~~
async function f() {   
	let response = await fetch('http://no-such-url'); }  // f() вернёт промис в состоянии rejected _
	f().catch(alert); // TypeError: failed to fetch // (*)_`
~~~
Если забыть добавить `.catch`, то будет сгенерирована ошибка «Uncaught promise error» и информация об этом будет выведена в консоль. Такие ошибки можно поймать глобальным обработчиком, о чём подробно написано в разделе [[1.3.3 Promise. Обработка ошибок]]

###### `async/await` и `promise.then/catch`

При работе с `async/await`, `.then` используется нечасто, так как `await` автоматически ожидает завершения выполнения промиса. В этом случае обычно (но не всегда) гораздо удобнее перехватывать ошибки, используя `try..catch`, нежели чем `.catch`.

Но на верхнем уровне вложенности (вне `async`–функций) `await` использовать нельзя, поэтому `.then/catch` для обработки финального результата или ошибок – обычная практика.

Так сделано в строке `(*)` в примере выше.

###### `async/await` отлично работает с `Promise.all`

Когда необходимо подождать несколько промисов одновременно, можно обернуть их в `Promise.all`, и затем `await`:
~~~
// await будет ждать массив с результатами выполнения всех промисов 
let results = await Promise.all([   
	fetch(url1),   fetch(url2),   ... ]);`
~~~
В случае ошибки она будет передаваться как обычно: от завершившегося с ошибкой промиса к `Promise.all`. А после будет сгенерировано исключение, которое можно отловить, обернув выражение в `try..catch`.




