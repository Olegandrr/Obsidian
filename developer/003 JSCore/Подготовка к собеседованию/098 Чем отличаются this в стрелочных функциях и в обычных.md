#### 15. Чем отличаются this в стрелочных функциях и в обычных? 
Подробнее: [[Контекст (this) в JS]]

-Контекстом вызова

##### This в обычных функциях 

Контекст обычной функции устанавливается в момент вызова функции. 
Это называется "поздним связыванием".

###### Подробнее
Если при вызове **слева от названия функции нет точки**, то контекстом функции является **глобальный контекст** (undefined в strict моде и window без него). Если же при вызове функции **слева от её названия есть точка**, то контекстом функции будет являться **объект, находящийся слева от точки**.

```js
obj /* <-- контекст функции*/
  .fn();
fn(); // контекст равен глобальному контексту (undefined в strict моде и window без него)
```

[1] Если **метод присвоить в переменную**, а затем функцию вызвать из этой переменной, **контекст будет потерян**, потому что слева от точки при вызове ничего не будет

```js
const obj = {
    fn() {
        console.log(this)
    },
};
obj.fn(); // obj

const fn = obj.fn;
fn() // глобальный контекст (undefined в strict моде и window без него)
```

[2] Если обычную функцию, при вызове которой контекст был равен глобальному контексту, **присвоить в объект**, а затем вызвать эту функцию как метод объекта, **контекстом функции станет этот объект**, потому что слева от точки при вызове функции будет расположен этот объект

```js
function fn() {
    console.log(this);
}

fn(); // глобальный контекст (undefined в strict моде и window без него)

const obj = {};
obj.fn = fn;

obj.fn(); // obj
```

[3] Если передать **ссылку на метод** в функцию и **вызвать его внутри неё**, то он будет вызван как обычная функция, а не как метод объекта, поэтому его **контекст будет утерян**.

```js
const someFn = (callback) => {
 callback(); // любая функция/метод, переданная сюда, будет вызвана без точки слева,
 // т.е. не от имени объекта. Это означает, что её контекст будет утерян
};

const obj = {
 method: function() {
  console.log(this);
 },
};

someFn(obj.method) // this будет равен undefined при use strict и window без него
```

Тем не менее мы можем **избежать** такого поведения, **обернув вызов** нашего метода в обычную или стрелочную функцию:

```js
const someFn = (callback) => {
 callback();
 /*
  Контекст все равно будет утерян, но утерян он будет у переданной функции,
  т.е. у нашей функции-обертки

  Вызов же метода в этой функции-обертке все равно делается через точку,
  т.е. от имени объекта.

  Благодаря этому, мы избегаем потери контекста
 */
};

const obj = {
    method: function() {
        console.log(this);
    },
};

someFn(() => obj.method()); // this в методе будет равен obj
someFn(function() { obj.method() }); // this в методе будет равен obj
```





##### This в стрелочных функциях

Контекст стрелочной функции устанавливается в момент объявления функции. 
Это называется **"ранним связыванием".**

###### Подробнее

Это также означает то, что **bind/apply/call** не дадут никакого результата при вызове на стрелочной функции.

```js
const fn = () => console.log(this); // this должен быть глобальным контекстом
// (undefined в strict моде и window без него)
fn.call({
  name: 'новый контекст',
}); /* Вызов через call должен принудительно привязать
 новый контекст к функции, но тем не менее this все равно равен глобальному контексту
 (undefined в strict моде и window без него) */
```

**Стрелочная функция не создает собственный контекст**, она берет его из внешнего лексического окружения:

[1] Если вы объявляете стрелочную функцию в глобальном контексте (не внутри функций/методов, но при этом сама стрелочная функция может быть методом), то контекстом этой стрелочной функции является глобальный контекст (undefined в strict моде и window без него)

```js
const fn = () => console.log(this);
const obj = {
  fn: () => console.log(this) /* контекст создают только функции,
   поэтому даже если стрелочная функция сама является
   методом объекта (не обернутого в функцию),
   контекстом для этой функции будет глобальный контекст
   (undefined в strict моде и window без него) */,
};

fn(); // глобальный контекст (undefined в strict моде и window без него)
obj.fn(); // глобальный контекст (undefined в strict моде и window без него)
```

[2] Если вы объявляете стрелочную функцию внутри другой функции/метода, то контекстом этой стрелочной функции будет контекст функции/метода, в котором эта стрелочная функция объявлена.

```js
const obj = {
  fn() {
    /* <-- стрелочная функция возьмет контекст этой функции,
      // а он равен obj, если вызывать ее через obj */
    const arrowFn = () => console.log(this);
    arrowFn();
  },
};

obj.fn(); // obj
```

[3] Исходя из пункта [1] и [2] можно сделать следующий совмещенный пример, чтобы глубже понять, как это работает:

```js
const obj = {
  // <-- контекст метода fn будет равен obj1,
  // если вызвать этот метод через точку (obj1.fn())
  fn1() {
    // <-- контекст стрелочной функции будет определен этой функцией,
    // т.к. она является ближайшей для него функцией
    return {
      fn2: () => {
        // функция возьмет контекст ближайшей внешней функции
        console.log(this);
      },
    };
  },
};

obj.fn1().fn2(); // this стрелочной функции = obj. fn1 возвращает внутренний объект,
// на котором вызывается метод fn2. Метод fn2 берет контекст ближайшей к нему функции -
// fn1, а та, в свою очередь, вызвана как метод объекта,
// значит ее контекстом и контекстом стрелочной функции будет obj
```







##### - This в цепочке object's prototype

Это же представление справедливо и для методов, определённых где-либо в цепочке object's prototype. Если метод находится в цепочке прототипов, то `this` ссылается на объект, на котором был вызван метод, т.е. так, словно метод является методом самого объекта, а не прототипа.

```
var o = {f:function(){ return this.a + this.b; }};
var p = Object.create(o);
p.a = 1;
p.b = 4;

console.log(p.f()); // 5
```

В этом примере объект, который присвоен переменной `p`, не имеет собственного свойства `f`, а наследует это свойство от своего прототипа. Однако, совершенно неважно, что поиск свойства f в конце концов обнаружит его на объекте `o`. Поскольку поиск начался с `p.f`, то и свойство `this` внутри функции `f` будет ссылаться на объект `p`. Таким образом, если `f` вызывается как метод `p`, то и `this` относится к `p`. Это полезная особенность прототипного наследования JS.

##### - This с геттерами/сеттерами

Все те же утверждения справедливы, если функция вызывается из геттера или сеттера. Для функции, которая используется как геттер или сеттер `this` привязан к объекту, свойство которого необходимо извлечь через геттер/сеттер.

```
function modulus(){
  return Math.sqrt(this.re * this.re + this.im * this.im);
}

var o = {
  re: 1,
  im: -1,
  get phase(){
    return Math.atan2(this.im, this.re);
  }
};

Object.defineProperty(o, 'modulus', {
    get: modulus, enumerable:true, configurable:true});

console.log(o.phase, o.modulus); // logs -0.78 1.4142
```

##### - This в конструкторе

Когда функция используется как конструктор (с ключевым словом [`new`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new) ), `this` связано с создаваемым новым объектом.

Примечание: по умолчанию конструктор возвращает объект, на который ссылается `this`, но он может вернуть и другой объект (если возвращаемое значение не является объектом, тогда будет возвращён объект с `this`).

```
/*
 * Конструктор работает таким образом:
 *
 * function MyConstructor(){
 *   // фактический код, составляющий тело функции.
 *   // создание свойств с |this| по
 *   // желанию, определяя их значения; например,
 *   this.fum = "nom";
 *   // и т.д.
 *
 *   // Если функция возвращает выражение,
 *   // возвращающее объект, этот объект будет
 *   // результатом выражения |new|. В обратном случае,
 *   // результат выражения - объект,
 *   // в данный момент привязанный к |this|
 *   // (т.е. наиболее часто встречающийся случай).
 * }
 */

function C() {
  this.a = 37;
}

var o = new C();
console.log(o.a); // logs 37


function C2() {
  this.a = 37;
  return {a: 38};
}

o = new C2();
console.log(o.a); // logs 38
```

В последнем примере (`C2`), из-за того, что конструктор вернул объект, новый объект, к которому было привязано `this`, был просто отброшен. (Это фактически делает выражение "`this.a = 37;`" "мёртвым" кодом. Он не является буквально нерабочим, так как он выполняется, но он может быть изъят без каких-либо внешних эффектов.)




___
 #JS 

___

### [[003 JSCore|Назад]]