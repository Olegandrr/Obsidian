#### 9. Можно ли изменять состояние #promise?

Пример, в котором исполнитель сообщит, что задача выполнена с ошибкой:
~~~
let promise = new Promise(function(resolve, reject) {   
// спустя одну секунду будет сообщено, что задача выполнена с ошибкой   
setTimeout(() => _reject__(new Error("Whoops!"))_, 1000); });`
~~~

![[Pasted image 20230218150248.png]]

Подведём промежуточные итоги: исполнитель выполняет задачу (что-то, что обычно требует времени), затем вызывает `resolve` или `reject`, чтобы изменить состояние соответствующего `Promise`.

Промис – и успешный, и отклонённый будем называть «завершённым», в отличие от изначального промиса «в ожидании».

	Может быть что-то одно: либо результат, либо ошибка

Исполнитель должен вызвать что-то одно: `resolve` или `reject`. Состояние промиса может быть изменено только один раз.

Все последующие вызовы `resolve` и `reject` будут проигнорированы:
~~~
`let promise = new Promise(function(resolve, reject) {   _
	resolve("done");_    
	reject(new Error("…")); // игнорируется   
	setTimeout(() => resolve("…")); // игнорируется });`
~~~
Идея в том, что задача, выполняемая исполнителем, может иметь только один итог: результат или ошибку.

Также заметим, что функция `resolve`/`reject` ожидает только один аргумент (или ни одного). Все дополнительные аргументы будут проигнорированы.

###### Вызывайте `reject` с объектом `Error`

В случае, если что-то пошло не так, мы должны вызвать `reject`. Это можно сделать с аргументом любого типа (как и `resolve`), но рекомендуется использовать объект `Error` (или унаследованный от него). Почему так? Скоро нам станет понятно.

###### Вызов `resolve`/`reject` сразу

Обычно исполнитель делает что-то асинхронное и после этого вызывает `resolve`/`reject`, то есть через какое-то время. Но это не обязательно, `resolve` или `reject` могут быть вызваны сразу:
~~~
let promise = new Promise(function(resolve, reject) {   
// задача, не требующая времени   
resolve(123); // мгновенно выдаст результат: 123 });`
~~~
Это может случиться, например, когда мы начали выполнять какую-то задачу, но тут же увидели, что ранее её уже выполняли, и результат закеширован.

Такая ситуация нормальна. Мы сразу получим успешно завершённый `Promise`.

###### Свойства `state` и `result` – внутренние

Свойства `state` и `result` – это внутренние свойства объекта `Promise` и мы не имеем к ним прямого доступа. Для обработки результата следует использовать методы `.then`/`.catch`/`.finally`, про них речь пойдёт дальше.

