##### Что такое цикл событий (event loop) и как он работает?
![Что такое цикл событий (event loop) и как он работает?](https://youtu.be/w-vUj0gHGgg?t=293)

![[Pasted image 20230723135412.png|600]]

JS является однопоточным (движок JS в 1 единицу времени может выполнять всего 1 операцию, для этого выделяется Стек). В стеке хранятся фреймы - это локальные аргументы  и переменные, которые хранятся в функции. 

Список событий, которые должны обрабатываться формируют очередь событий. Когда стек освобождается движок может обработать любое событие из этой очереди. 

Координирование этого процесса и происходит в EventLoop.

##### Разница между микро и макрозадачами в event loop?
![Разница между микро и макрозадачами в event loop?](https://youtu.be/hL5yFo9Pms4?t=249)

![[Pasted image 20230723135740.png|600]]

**EventLoop** - это механизм, используемый браузером или Node.js для управления асинхронным кодом. Он позволяет синхронизировать callstack и очередь задач.

**Макрозадачи** - это задачи, которые добавляются в очередь и добавляются после того как очередь задач пуста.

Макрозадачи включают в себя:
* элементы пользовательского ввода;
* таймеры;
* загрузка и ресурсов
* и другие асинхронные задачи.

**Микрозадачи** - это задачи, которые добавляются в очередь микрозадач, после того как стек вызовов пуст, но до того, как будут выполнены макрозадачи.

Микрозадачи включают в себя:
* обработчики промисов.
* обработчики notationObserver.
* функции добавленные с помощью queueMicrotask.

##### Расскажите о `queueMicrotask`?
![Расскажите о `queueMicrotask`?](https://youtu.be/hL5yFo9Pms4?t=330)

![[Pasted image 20230723140208.png|600]]

**queueMicrotask** - это JS метод, который используется для добавления переданной в неё функции в очередь микрозадач, внутри EventLoop.

#### Ответ

Единственное место, через которое задачи могут попасть в CallStack и выполниться — это EventLoop.
	Задачи могут быть трех типов:
	* микрозадача 
	* макрозадача (приоритетенее)
	* обработка через рендер (визуализация сайта)

![[Pasted image 20230218194535.png]]

Идея событийный-цикл очень проста.
Есть бесконечный цикл, в котором движок JavaScript ожидает задачи *(реагирование на движение мыши, обработка событий мыши, загрузка внешнего скрипта, setTimeout и др.)*, исполняет их и снова ожидает появления новых.

Очередь, которую формируют такие задачи, называют **очередь-макрозадач**

![[Pasted image 20230218132810.png]]
_Рисунок 2 Очередь макрозадач и событийный цикл

Задачи из очереди исполняются по правилу «первым пришёл – первым ушёл». Когда браузер заканчивает выполнение скрипта, он обрабатывает событие `mousemove`, затем выполняет обработчик, заданный `setTimeout`, и так далее.

Помимо _макрозадач, существуют микрозадачи.

Асинхронные задачи требуют правильного управления. Для этого стандарт предусматривает внутреннюю очередь `PromiseJobs`, более известную как **очередь-микрозадач** (microtask queue)».

Микрозадачи приходят только из кода. Обычно они создаются promise : выполнение обработчика `.then/catch/finally` становится микрозадачей. Микрозадачи также используются «под капотом» `await`, т.к. это форма обработки промиса.

Также есть специальная функция `queueMicrotask(func)`, которая помещает `func` в очередь микрозадач.

Если у кого-то из заказчиков не оказалось задач, то Event Loop просто идет к следующему. И, наоборот, если у заказчика задачи занимают много времени, то остальные заказчики будут ждать своей очереди. А если задачи от какого-то заказчика оказались бесконечными, то CallStack переполняется, и браузер начинает ругаться:

![[Pasted image 20230218195348.png]]
_Рисунок 3 Страница не отвечает

Есть код: 

~~~javascript
let promise = Promise.resolve();  
promise.then(() => alert("промис выполнен"));  
alert("код выполнен"); // этот alert показывается первым`
~~~

Или, проще говоря, когда промис выполнен, его обработчики `.then/catch/finally` попадают в очередь-микрозадач. Они пока не выполняются. Движок JavaScript берёт задачу из очереди и выполняет её, когда он освободится от выполнения текущего кода.

Вот почему сообщение «код выполнен» в примере выше будет показано первым.

На основе этой схемы строится вся работа Event Loop.

###### Упрощенный алгоритм 


1.  Исполнить все _микрозадачи_:
    -   Пока очередь микрозадач не пуста: - Выбрать из очереди и исполнить старейшую микрозадачу
2.  Выбрать и исполнить старейшую задачу из очереди _макрозадач_ (например, «script»).
3.  Отрисовать изменения страницы, если они есть.
4.  Если очередь микрозадач пуста – подождать, пока появится микрозадача.
5.  Перейти к шагу 1.

Подробнее: [[1.1.1 Событийный цикл. Микрозадачи и макрозадачи|Событийный цикл? Микрозадачи и макрозадачи]] , [[1.5.3 Объяснение работы EventLoop в JavaScript|Объяснение работы EventLoop в JavaScript]]  ,  [Интересная статья про EventLoop](https://habr.com/ru/post/461401/)

___
 #JavaScript #EventLoop #CallStack #microtask #macrotask #

___

### [[003 JSCore|Назад]]