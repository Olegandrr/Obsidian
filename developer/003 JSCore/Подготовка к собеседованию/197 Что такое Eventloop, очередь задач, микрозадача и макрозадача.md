![Что такое цикл событий (event loop) и как он работает?](https://youtu.be/w-vUj0gHGgg?t=293)


![Разница между микро и макрозадачами в event loop?](https://youtu.be/hL5yFo9Pms4?t=249)

![Расскажите о `queueMicrotask`?](https://youtu.be/hL5yFo9Pms4?t=330)

#### 5. Что такое #Eventloop, очередь задач, #микрозадача и #макрозадача?  
Подробнее: [[1.1.1 Событийный цикл. Микрозадачи и макрозадачи]] , [[1.5.3 Объяснение работы EventLoop в JavaScript]]  ,  [Интересная статья про EventLoop](https://habr.com/ru/post/461401/)

Единственное место, через которое задачи могут попасть в #CallStack и выполниться — это #EventLoop.
	Задачи могут быть трех типов:
	* #микрозадача 
	* #макрозадача (приоритетенее)
	* обработка через рендер (визуализация сайта)

![[Pasted image 20230218194535.png]]

Идея #событийный-цикл очень проста.
Есть бесконечный цикл, в котором движок JavaScript ожидает задачи (реагирование на движение мыши, обработка событий мыши, загрузка внешнего скрипта, setTimeout и др), исполняет их и снова ожидает появления новых.

Очередь, которую формируют такие задачи, называют #очередь-макрозадач
![[Pasted image 20230218132810.png]]
_Рисунок 2 Очередь макрозадач и событийный цикл

Задачи из очереди исполняются по правилу «первым пришёл – первым ушёл». Когда браузер заканчивает выполнение скрипта, он обрабатывает событие `mousemove`, затем выполняет обработчик, заданный `setTimeout`, и так далее.

Помимо _макрозадач, существуют микрозадачи.

Асинхронные задачи требуют правильного управления. Для этого стандарт предусматривает внутреннюю очередь `PromiseJobs`, более известную как #очередь-микрозадач (microtask queue)».

Микрозадачи приходят только из кода. Обычно они создаются #promise : выполнение обработчика `.then/catch/finally` становится микрозадачей. Микрозадачи также используются «под капотом» `await`, т.к. это форма обработки промиса.

Также есть специальная функция `queueMicrotask(func)`, которая помещает `func` в очередь микрозадач.

Если у кого-то из заказчиков не оказалось задач, то Event Loop просто идет к следующему. 
И, наоборот, если у заказчика задачи занимают много времени, то остальные заказчики будут ждать своей очереди. А если задачи от какого-то заказчика оказались бесконечными, то #CallStack переполняется, и браузер начинает ругаться:

![[Pasted image 20230218195348.png]]
_Рисунок 3 Страница не отвечает

Есть код: 

~~~
`let promise = Promise.resolve();  
promise.then(() => alert("промис выполнен"));  
alert("код выполнен"); // этот alert показывается первым`
~~~

Или, проще говоря, когда промис выполнен, его обработчики `.then/catch/finally` попадают в #очередь-микрозадач. Они пока не выполняются. Движок JavaScript берёт задачу из очереди и выполняет её, когда он освободится от выполнения текущего кода.

Вот почему сообщение «код выполнен» в примере выше будет показано первым.

На основе этой схемы строится вся работа Event Loop.

###### Упрощенный алгоритм 

1.  Выбрать и исполнить старейшую задачу из очереди _макрозадач_ (например, «script»).
2.  Исполнить все _микрозадачи_:
    -   Пока очередь микрозадач не пуста: - Выбрать из очереди и исполнить старейшую микрозадачу
3.  Отрисовать изменения страницы, если они есть.
4.  Если очередь макрозадач пуста – подождать, пока появится макрозадача.
5.  Перейти к шагу 1.

___
 #JS 

___

### [[003 JSCore|Назад]]