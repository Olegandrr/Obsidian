#### 4. #Многопоточность против асинхронного программирования
###### Коротко о главном

Из приведенных нами определений мы можем видеть, что **многопоточное программирование - это одновременное выполнение различных функций. Асинхронное программирование - это неблокирующее выполнение между функциями**, и мы можем применять асинхронность при однопоточном или многопоточном программировании.

Итак, многопоточность - это одна из форм асинхронного программирования.

Давайте проведем простую аналогию; у вас есть друг, и вы решили вместе приготовить ужин.

Асинхронность - это когда вы говорите своему другу: “Ты идешь в магазин и покупаешь макароны. **Дай мне знать, когда вернешься**, чтобы вместе приготовить ужин. **Тем временем я приготовлю соус и напитки** ”.

Многопоточность - это “вы кипятите воду. Я подогрею томатный соус. Пока вода кипит, спросите меня, и я положу макароны. Когда соус остынет, можно добавить сыр. Когда оба будут сделаны, я сяду, а вы подадите ужин. Затем мы едим ”. **В аналогии с потоками мы можем видеть последовательность событий “Когда, сделай”, которые представляют последовательный набор инструкций для каждого пользователя (потока).**

Из этой аналогии мы можем сделать вывод, что **_многопоточность_ касается рабочих, _асинхронность_ - задач.**

**Выбор между двумя моделями программирования зависит в основном от _производительности_.**

Учитывая все возможные комбинации между синхронизацией / асинхронностью и однопоточностью / многопоточностью, какая модель должна работать лучше?

**В двух словах, для крупномасштабных приложений с большим количеством операций ввода-вывода и различных вычислений, использование асинхронного многопоточного потока программирования будет использовать вычислительные ресурсы и заботиться о неблокирующих функциях.**Это модель программирования любой ОС!

С большей мощностью приходит больше ответственности! Итак, если мы решили реализовать эту модель, мы должны позаботиться о различных проблемах, таких как состояние гонки, взаимоблокировки, общие ресурсы и события обратного вызова.

###### Конкурентность (concurrency)

Конкурентность (*) #concurrency - это наиболее общий термин, который говорит, что одновременно выполняется более одной задачи. Например, вы можете одновременно смотреть телевизор и комментить фоточки в фейсбуке. Винда, даже 95-я могла (**) одновременно играть музыку и показывать фотки.

(*) К сожалению, вменяемого русскоязычного термина я не знаю. Википедия говорит, что concurrent computing - это параллельные вычисления, но как тогда будет parallel computing по русски?

(**) Да, вспоминается анекдот про Билла Гейтса и многозадачность винды, но, _теоретически_ винда могла делать несколько дел одновременно. Хотя и не любых.

Конкурентное исполнение - это самый общий термин, который не говорит о том, каким образом эта конкурентность будет получена: путем приостановки некоторых вычислительных элементов и их переключение на другую задачу, путем действительно одновременного исполнения, путем делегации работы другим устройствам или еще как-то. Это не важно.

_Конкурентное исполнение_ говорит о том, что за определенный промежуток времени будет решена более, чем одна задача. Точка.

###### Параллельное исполнение

Параллельное исполнение (parallel computing) подразумевает наличие более одного вычислительного устройства (например, процессора), которые будут _одновременно_ выполнять несколько задач.

Параллельное исполнение - это строгое подмножество конкурентного исполнения. Это значит, что на компьютере с одним процессором параллельное программирование - невозможно;)

###### Многопоточность

#Многопоточность - это один из способов реализации конкурентного исполнения путем выделения абстракции "рабочего потока" (worker thread).

Потоки "абстрагируют" от пользователя низкоуровневые детали и позволяют выполнять более чем одну работу "параллельно". Операционная система, среда исполнения или библиотека прячет подробности того, будет многопоточное исполнение конкурентным (когда потоков больше чем физических процессоров), или параллельным (когда число потоков меньше или равно числу процессоров и несколько задач физически выполняются одновременно).

###### Асинхронное исполнение

#Асинхронность (asynchrony) подразумевает, что операция может быть выполнена кем-то на стороне: удаленным веб-узлом, сервером или другим устройством за пределами текущего вычислительного устройства.

Основное свойство таких операций в том, что начало такой операции требует значительно меньшего времени, чем основная работа. Что позволяет выполнять множество асинхронных операций одновременно даже на устройстве с небольшим числом вычислительных устройств.

###### CPU-bound и IO-Bound операции

Еще один важный момент, с точки зрения разработчика - разница между CPU-bound и IO-bound операциями. CPU-Bound операции нагружают вычислительные мощности текущего устройства, а IO-Bound позволяют выполнить задачу вне текущей железки.

Разница важна тем, что число одновременных операций зависит от того, к какой категории они относятся. Вполне нормально запустить параллельно сотни IO-Bound операций, и надеяться, что хватит ресурсов обработать все результаты. Запускать же параллельно слишком большое число CPU-bound операций (больше, чем число вычислительных устройств) бессмысленно.

---

Возвращаясь к исходному вопросу: нет смысла выполнять в 1000 потоков метод `Calc`, если он является CPU-Intensive (нагружает центральный процессор), поскольку это приведет к падению общей эффективности вычислений. ОС-ке придется переключать несколько доступных ядер для обслуживания сотен потоков. А этот процесс не является дешевым.

Самым простым и эффективным способом решения CPU-Intensive задачи, заключается в использовании идиомы Fork-Join: задачу (например, входные данные) нужно разбить на определенное число подзадач, которые можно выполнить параллельно. Каждая подзадача должна быть независимой и не обращаться к разделяемым переменным/памяти. Затем, нужно собрать промежуточные результаты и объединить их.

Именно на этом принципе основан PLINQ. О чем можно почитать тут: [Джозеф Албахари. Параллельное программирование](http://sergeyteplyakov.blogspot.com/2010/09/51.html).

Выглядит это очень интересно:

```csharp
IEnumerable<Data> yourData = GetYourData();
var result = yourData.AsParallel() // начинаем обрабатывать параллельно
  .Select(d => ComputeMD5(d)) // Вычисляем параллельно
  .Where(md5 => IsValid(md5))
  .ToArray(); // Возврвщаемся к синхронной модели
```

В этом случае, число потоков будет контролироваться библиотечным кодом в недрах CLR/TPL и метод `ComputeMD5` будет вызван параллельно N-раз на компьютере с N-процессорами (ядрами).

