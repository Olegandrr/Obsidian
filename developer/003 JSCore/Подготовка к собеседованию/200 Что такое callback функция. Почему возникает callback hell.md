![Что такое callback-функция? Что такое Callback Hell?](https://youtu.be/V-m0sQ-hW58?t=348)

#### 7. Что такое #callback функция? Почему возникает callback hell?
Подробнее: [[1.2 CallBack функции]]

###### Что такое callback функция?

#CallBack — это функция, которая должна быть выполнена после того, как другая функция завершит работу. Создадим собственную функцию обратного вызова.  
  
Для начала — откройте консоль разработчика Chrome (`Ctrl + Shift + J` в Windowsи введите следующее:  

```
function doHomework(subject) {
  alert(`Starting my ${subject} homework.`);
}
```

Тут мы объявили функцию `doHomework()`. Эта функция принимает одну переменную — название предмета, по которому некто делает домашнюю работу. Вызовите функцию, введя в консоли следующее:  
  
```
doHomework('math');
// Выводит сообщение: Starting my math homework.
```

Теперь добавим, в качестве второго аргумента функции `doHomework()`, параметр `callback`, который будем использовать для того, чтобы передать `doHomework()` функцию обратного вызова. Теперь код будет выглядеть так:  
  
```
function doHomework(subject, callback) {
  alert(`Starting my ${subject} homework.`);
  callback();
}
```

Вызовем обновлённую функцию следующими образом:  
  
```
doHomework('math', function() {
  alert('Finished my homework');
});
```

Сначала будет выведено сообщение с текстом `Starting my math homework.`, потом — с текстом `Finished my homework`.  
  
Функции обратного вызова совсем необязательно создавать непосредственно при вызове функций, которым они передаются. Такую функцию можно объявить и где-нибудь в коде:  
  
```
function doHomework(subject, callback) {
  alert(`Starting my ${subject} homework.`);
  callback();
}
function alertFinished(){
  alert('Finished my homework');
}
doHomework('math', alertFinished);
```

После вызова функции `doHomework()` всё будет выглядеть точно так же, как в предыдущем примере. Различия заключаются лишь в том, как мы работаем с функцией обратного вызова.  
  
###### Почему возникает callback hell?

#Callback может выполнять асинхронные действий: то есть действия, которые выполняются друг за другом.

~~~
loadScript('1.js', function(error, script) {    
	if (error) {     
		handleError(error);   
	} else {     // ...     
		loadScript('2.js', 
		function(error, script) {       
			if (error) {         
				handleError(error);       
			} else {         // ...         
				loadScript('3.js', 
				function(error, script) {           
					if (error) {             
						handleError(error);           
						} else {   // ...и так далее, пока все скрипты не будут загружены (*)
						}         });        }     })   } });`
~~~

В примере выше:
1.  Мы загружаем `1.js`. Продолжаем, если нет ошибок.
2.  Мы загружаем `2.js`. Продолжаем, если нет ошибок.
3.  Мы загружаем `3.js`. Продолжаем, если нет ошибок. И так далее `(*)`.

Чем больше вложенных вызовов, тем наш код будет иметь всё большую вложенность, которую сложно поддерживать, особенно если вместо `...` у нас код, содержащий другие цепочки вызовов, условия и т.д.
Иногда это называют «адом колбэков» или «адской пирамидой колбэков».

`Такой подход к написанию кода не приветствуется`
Лучший способ избежать применения #callback-hell использовать #promise .



