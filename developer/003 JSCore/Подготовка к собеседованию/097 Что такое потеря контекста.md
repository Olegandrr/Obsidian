#### 18. Что такое потеря контекста?  

Грубо говоря, `this` — это ссылка на некий объект, к свойствам которого можно получить доступ внутри вызова функции. Этот `this` — и есть _контекст выполнения_.

Потеря контекста определяется тем, как вызван #this, а не тем, где она определена.

Если мы попытаемся вызвать метод в рамках объекта, у которого нет нужных свойств, то будет ошибка Это называется потеря контекста. Reference Type

Рассмотрим пример.
```javascript
let car = {
  maxSpeed: 10,
  chargingHours: 5,
  getMaxDistance() {
    return this.maxSpeed * this.chargingHours;
  }
}

let maxDistance = car.getMaxDistance;

console.log(maxDistance()); // Ошибка
```
В переменную maxDistance мы присвоили не результат функции, а ссылку на эту функцию (Reference Type), так как функция является объектом.

##### Способы избежать потери контекста
###### #1 Обернуть в анонимную функцию.

Обернуть вызов в анонимную функцию. Тут сработало замыкание. При передаче функции в очередь, движок также передал туда все видимые переменные в рамках области видимости, в том числе объект car.

```javascript
setTimeout(function() {
  car.getMaxDistance();
}, 1000) // 50
```

Но тут есть нюанс, если до выполнения функции в setTimeout измениться объект car, то это отразится на результате его выполнения.

```javascript
setTimeout(function() {
  car.getMaxDistance();
}, 1000) // 45 мы можем не узнать о том, что с объектом, что-то произошло

// Выполнится раньше чем setTimeout
car.getMaxDistance = function() {
  console.log(this.maxSpeed * this.chargingHours * 0.9);
}
```

###### #2 Привязываем контекст с помощью #bind

bind возвращает специальный метод, который сохраняет функциональность, но строго привязывает ее к определенному объекту.

```javascript
let carMaxDistance = car.getMaxDistance.bind(car);

setTimeout(carMaxDistance, 1000) // 50

// Выполнится раньше чем setTimeout, но нам уже все равно
car.getMaxDistance = function() {
  console.log(this.maxSpeed * this.chargingHours * 0.9);
}
```

Теперь мы можем гарантировать, что метод выполнится корректно по отношению к объекту

###### #3 Использовать стрелочные функции

Особенность стрелочной функции в том, что у нее вообще нет контекста. Он определяется в момент создания.

```javascript
const showContext = () => {
  console.log(this); // undefined
}
```

Пример потери контекста с обычной функцией

```javascript
function Car() {
  // В конструкторе Person() `this` указывает на себя.
  this.speed = 0;
  
  // Каждую секунду увеличиваем скорость
  setInterval(function incrementSpeed() {
    this.speed++; // Нет доступа к свойству
    console.log(this.speed); // NaN
  }, 1000);
}

let car = new Car();
```

Решение с помощью стрелочной функции

```javascript
function Car() {
  this.speed = 0;

  setInterval(() => {
    this.speed++;
    console.log(this.speed);
  }, 1000);
}

let car = new Car();
```

Так как у стрелочной функции контекст определяется в момент создания, то мы запомнили свойство speed в контексте вызова функции.

###### Подведем итог

-   У обычной функции контекст создается в момент вызова. Вне объекта он равен window
-   Когда мы вызываем функцию через точку object.method(), то контекстом является объект до точки object
-   Стрелочная функция не имеет контекста и сохраняет его в момент создания
-   метод bind помогает привязать контекст выполнения к функции
