![Что такое `async/await`?](https://youtu.be/V-m0sQ-hW58?t=417)


#### 13. Что такое #async / #await?
Подробнее: [[1.4 ASync. await]]

Существует специальный синтаксис для работы с промисами, который называется «async/await». 

##### Async

Начнём с ключевого слова `async`. Оно ставится перед функцией, вот так:
~~~
async function f() {   
	return 1; }`
~~~

###### Что возвращает async функция? А если явно возвращать примитивное значение?

У слова `async` один простой смысл: эта функция всегда возвращает промис. 
Значения других типов оборачиваются в завершившийся успешно промис автоматически.

Например, эта функция возвратит выполненный промис с результатом `1`:
~~~
async function f() {   
	return 1; }  
f().then(alert); // 1`
~~~
Можно и явно вернуть промис, результат будет одинаковым:
~~~
async function f() {   
	return Promise.resolve(1); }  
f().then(alert); // 1`
~~~
Так что ключевое слово `async` перед функцией гарантирует, что эта функция в любом случае вернёт промис. 


##### Await

Синтаксис:  `// работает только внутри async–функций let value = await promise;`

Ключевое слово `await` заставит интерпретатор JS ждать до тех пор, пока промис справа от `await` не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится.

В этом примере промис успешно выполнится через 1 секунду:
~~~
async function f() {    
	let promise = new Promise((resolve, reject) => {     
		setTimeout(() => resolve("готово!"), 1000)   });    _
	let result = await promise; // будет ждать, пока промис не выполнится (*)_    
	alert(result); // "готово!" }  
f();`
~~~
В данном примере выполнение функции остановится на строке `(*)` до тех пор, пока промис не выполнится. Это произойдёт через секунду после запуска функции. После чего в переменную `result` будет записан результат выполнения промиса, и браузер отобразит alert-окно «готово!».

Обратите внимание, хотя `await` и заставляет JavaScript дожидаться выполнения промиса, это не отнимает ресурсов процессора. Пока промис не выполнится, JS-движок может заниматься другими задачами: выполнять прочие скрипты, обрабатывать события и т.п.

По сути, это просто «синтаксический сахар» для получения результата промиса, более наглядный, чем `promise.then`.

###### Можно ли использовать await без async?

`Await` можно использовать только внутри `async`-функций.

#####  Как использовать async/await в коде? 

`await` нельзя использовать в обычных функциях
Если мы попробуем использовать `await` внутри функции, объявленной без `async`, получим синтаксическую ошибку:
~~~
`function f() {   
	let promise = Promise.resolve(1);   _
	let result = await promise; // SyntaxError_ }`
~~~
Ошибки не будет, если мы укажем ключевое слово `async` перед объявлением функции. 
Как было сказано раньше, `await` можно использовать только внутри `async`–функций.

Давайте перепишем пример `showAvatar()` из раздела [Цепочка промисов](https://learn.javascript.ru/promise-chaining) с помощью `async/await`:

1.  Нам нужно заменить вызовы `.then` на `await`.
2.  И добавить ключевое слово `async` перед объявлением функции.
~~~
async function showAvatar() {    
// запрашиваем JSON с данными пользователя   
	let response = await fetch('/article/promise-chaining/user.json');   
	let user = await response.json();    // запрашиваем информацию об этом пользователе из github   
	let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);   
	let githubUser = await githubResponse.json();    // отображаем аватар пользователя   
	let img = document.createElement('img');   
	img.src = githubUser.avatar_url;   
	img.className = "promise-avatar-example";   
	document.body.append(img);    // ждём 3 секунды и затем скрываем аватар   
	
	await new Promise((resolve, reject) => setTimeout(resolve, 3000));    
	img.remove();    
	return githubUser; }  showAvatar();``
~~~
Получилось очень просто и читаемо, правда? Гораздо лучше, чем раньше.

`await` нельзя использовать на верхнем уровне вложенности

Программисты, узнав об `await`, часто пытаются использовать эту возможность на верхнем уровне вложенности (вне тела функции). Но из-за того, что `await` работает только внутри `async`–функций, так сделать не получится:
~~~
`// SyntaxError на верхнем уровне вложенности 
let response = await fetch('/article/promise-chaining/user.json'); 
let user = await response.json();`
~~~
Можно обернуть этот код в анонимную `async`–функцию, тогда всё заработает:
~~~
`(async () => {   
	let response = await fetch('/article/promise-chaining/user.json');   
	let user = await response.json();   ... })();`
~~~

`await` работает с #thenable–объектами

Как и `promise.then`, `await` позволяет работать с промис–совместимыми объектами. Идея в том, что если у объекта можно вызвать метод `then`, этого достаточно, чтобы использовать его с `await`.

В примере ниже, экземпляры класса `Thenable` будут работать вместе с `await`:
~~~
`class Thenable {   
	constructor(num) {     
	this.num = num;   
	}   then(resolve, reject) {     
		alert(resolve);     // выполнить resolve со значением this.num * 2 через 1000мс     
		setTimeout(() => resolve(this.num * 2), 1000); // (*)   } };  

async function f() {   // код будет ждать 1 секунду,   // после чего значение result станет равным 2   
	let result = await new Thenable(1);   
	alert(result); }  f();`
~~~
Когда `await` получает объект с `.then`, не являющийся промисом, JavaScript автоматически запускает этот метод, передавая ему аргументы – встроенные функции `resolve` и `reject`. Затем `await` приостановит дальнейшее выполнение кода, пока любая из этих функций не будет вызвана (в примере это строка `(*)`). После чего выполнение кода продолжится с результатом `resolve` или `reject` соответственно.

###### Асинхронные методы классов

Для объявления асинхронного метода достаточно написать `async` перед именем:
~~~
class Waiter {   _
	async wait() {_     
		return await Promise.resolve(1);   } }  

new Waiter()   
.wait()   
.then(alert); // 1`
~~~
Как и в случае с асинхронными функциями, такой метод гарантированно возвращает промис, и в его теле можно использовать `await`.






