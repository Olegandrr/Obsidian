![Что такое промисы (Promises)?](https://youtu.be/G4iYlbilozM?t=371)

#### 8. Что такое #promise? Как они решают проблему callback hell?

#Promise – это специальный объект в JS, который связывает «создающий» и «потребляющий» коды вместе. 

Синтаксис создания `Promise`:
~~~
let promise = new Promise(function(resolve, reject) {   
// функция-исполнитель (executor)   // "певец" });`
~~~
Функция, переданная в конструкцию `new Promise`, называется _исполнитель_ (executor). Когда `Promise` создаётся, она запускается автоматически. Она должна содержать «создающий» код, который когда-нибудь создаст результат.
Её аргументы `resolve` и `reject` – это колбэки, которые предоставляет сам JavaScript. 
Наш код – только внутри исполнителя.

Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:
-   `resolve(value)` — если работа завершилась успешно, с результатом `value`.
-   `reject(error)` — если произошла ошибка, `error` – объект ошибки.

Итак, исполнитель запускается автоматически, он должен выполнить работу, а затем вызвать `resolve` или `reject`.

У объекта `promise`, возвращаемого конструктором `new Promise`, есть внутренние свойства:
-   `state` («состояние») — вначале `"pending"` («ожидание»), потом меняется на `"fulfilled"` («выполнено успешно») при вызове `resolve` или на `"rejected"` («выполнено с ошибкой») при вызове `reject`.
-   `result` («результат») — вначале `undefined`, далее изменяется на `value` при вызове `resolve(value)` или на `error` при вызове `reject(error)`.

Так что исполнитель по итогу переводит `promise` в одно из двух состояний:
![[Pasted image 20230218150041.png]]

У нас есть функция `loadScript` для загрузки скрипта из предыдущей главы.
Давайте вспомним, как выглядел вариант с колбэками:
~~~
``function loadScript(src, callback) {   
	let script = document.createElement('script');   
	script.src = src;    
	script.onload = () => callback(null, script);   
	script.onerror = () => callback(new Error(`Ошибка загрузки скрипта ${src}`));    
	document.head.append(script); }``
~~~
Теперь перепишем её, используя `Promise`.

Новой функции `loadScript` более не нужен аргумент `callback`. 
Вместо этого она будет создавать и возвращать объект `Promise`, который перейдет в состояние «успешно завершён», когда загрузка закончится. Внешний код может добавлять обработчики («подписчиков»), используя `.then`:
~~~
``function loadScript(src) {   
	return new Promise(function(resolve, reject) {     
		let script = document.createElement('script');     
		script.src = src;      
		script.onload = () => resolve(script);     
		script.onerror = () => reject(new Error(`Ошибка загрузки скрипта ${src}`));      
		document.head.append(script);   }); }``
~~~
Применение:
~~~
``
let promise = loadScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");  
promise.then(   
	script => alert(`${script.src} загружен!`),   
	error => alert(`Ошибка: ${error.message}`) );  
	promise.then(script => alert('Ещё один обработчик...'));``
~~~
Сразу заметно несколько преимуществ перед подходом с использованием колбэков:

###### Промисы

1. Промисы позволяют делать вещи в естественном порядке. Сперва мы запускаем `loadScript(script)`, и затем (`.then`) мы пишем, что делать с результатом.
2. Мы можем вызывать `.then` у `Promise` столько раз, сколько захотим. Каждый раз мы добавляем нового «фаната», новую функцию-подписчика в «список подписок». Больше об этом в следующей главе: [Цепочка промисов](https://learn.javascript.ru/promise-chaining).

Таким образом, промисы позволяют улучшить порядок кода и дают нам гибкость. Но это далеко не всё. Мы узнаем ещё много полезного в последующих главах.

###### Колбэки

У нас должна быть функция`callback` на момент вызова `loadScript(script, callback)`. Другими словами, нам нужно знать что делать с результатом _до того_, как вызовется `loadScript`.

Колбэк может быть только один.

