# 32. Насколько вы опытны в работе с промисами (promises) и или их полифилами

Promise – это специальный объект, который содержит своё состояние. Вначале `pending` («ожидание»), затем – одно из: `fulfilled` («выполнено успешно») или `rejected` («выполнено с ошибкой»).

На `promise` можно навешивать колбэки двух типов:

·         `onFulfilled` – срабатывают, когда `promise` в состоянии «выполнен успешно».

·         `onRejected` – срабатывают, когда `promise` в состоянии «выполнен с ошибкой».

Способ использования, в общих чертах, такой:

1.      Код, которому надо сделать что-то асинхронно, создаёт объект `promise` и возвращает его.

2.      Внешний код, получив `promise`, навешивает на него обработчики.

3.      По завершении процесса асинхронный код переводит `promise` в состояние `fulfilled` (с результатом) или `rejected` (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.

Синтаксис создания `Promise`:

var `promise` = new Promise(function(resolve, reject) {

```
  
```

```
  
```

```
  
```

```
  
```

```
  
```

})

Универсальный метод для навешивания обработчиков:

```
promise
```

·         `onFulfilled` – функция, которая будет вызвана с результатом при `resolve`.

·         `onRejected` – функция, которая будет вызвана с ошибкой при `reject`.

С его помощью можно назначить как оба обработчика сразу, так и только один:

// onFulfilled сработает при успешном выполнении

```
promise
```

// onRejected сработает при ошибке

```
promise
```

**.****catch**

Для того, чтобы поставить обработчик только на ошибку, вместо `.``then``(``null``,` `onRejected``)` можно написать `.``catch``(``onRejected``)` – это то же самое.

**Синхронный** `**throw**` **– то же самое, что** `**reject**`

Если в функции промиса происходит синхронный `throw` (или иная ошибка), то вызывается `reject`:

'use strict';

let `p` = new Promise((resolve, reject) => {

```
  
```

```
  
```

})

```
p
```

Посмотрим, как это выглядит вместе, на простом примере.

[Пример с setTimeout](https://learn.javascript.ru/promise#primer-s-settimeout)

Возьмём `setTimeout` в качестве асинхронной операции, которая должна через некоторое время успешно завершиться с результатом «result»:

'use strict';

// Создаётся объект promise

let `promise` = new Promise((resolve, reject) => {

```
  
```

```
    
```

```
    
```

```
  
```

});

// promise.then навешивает обработчики на успешный результат или ошибку

```
promise
```

```
  
```

```
    
```

```
      
```

```
      
```

```
    
```

```
    
```

```
      
```

```
      
```

```
    
```

```
  
```

В результате запуска кода выше – через 1 секунду выведется «Fulfilled: result».

А если бы вместо `resolve("result")` был вызов `reject("error")`, то вывелось бы «Rejected: error». Впрочем, как правило, если при выполнении возникла проблема, то `reject` вызывают не со строкой, а с объектом ошибки типа `new Error`:

// Этот promise завершится с ошибкой через 1 секунду

var `promise` = new Promise((resolve, reject) => {

```
  
```

    reject(new Error("время вышло!"));

```
  
```

});

```
promise
```

```
  
```

```
    
```

    error => alert("Rejected: " + _error_._message_) // Rejected: время вышло!

```
  
```

Конечно, вместо `setTimeout` внутри функции промиса может быть и запрос к серверу и ожидание ввода пользователя, или другой асинхронный процесс. Главное, чтобы по своему завершению он вызвал `resolve` или `reject`, которые передадут результат обработчикам.

**Только один аргумент**

Функции `resolve/reject` принимают ровно один аргумент – результат/ошибку.

Именно он передаётся обработчикам в `.then`, как можно видеть в примерах выше.

[Promise после reject/resolve – неизменны](https://learn.javascript.ru/promise#promise-posle-reject-resolve-neizmenny)

Заметим, что после вызова `resolve/reject` промис уже не может «передумать».

Когда промис переходит в состояние «выполнен» – с результатом (resolve) или ошибкой (reject) – это навсегда.

Например:

'use strict';

let `promise` = new Promise((resolve, reject) => {

  // через 1 секунду готов результат: result

```
  
```

  // через 2 секунды — reject с ошибкой, он будет проигнорирован

```
  
```

});

```
promise
```

```
  
```

```
    
```

```
    
```

```
  
```

В результате вызова этого кода сработает только первый обработчик `then`, так как после вызова `resolve` промис уже получил состояние (с результатом), и в дальнейшем его уже ничто не изменит.

Последующие вызовы resolve/reject будут просто проигнорированы.

А так – наоборот, ошибка будет раньше:

'use strict';

let `promise` = new Promise((resolve, reject) => {

```
  
```

```
  
```

```
  
```

});

```
promise
```

```
  
```

```
    
```

```
    
```

```
  
```

[Промисификация](https://learn.javascript.ru/promise#promisifikatsiya)

_Промисификация_ – это когда берут асинхронную функциональность и делают для неё обёртку, возвращающую промис.

После промисификации использование функциональности зачастую становится гораздо удобнее.

В качестве примера сделаем такую обёртку для запросов при помощи XMLHttpRequest.

Функция `httpGet(url)` будет возвращать промис, который при успешной загрузке данных с `url` будет переходить в `fulfilled` с этими данными, а при ошибке – в `rejected` с информацией об ошибке:

function httpGet(url) {

```
  
```

```
    
```

```
    xhr
```

```
    xhr
```

```
      
```

        resolve(this._response_);

```
      
```

        var _error_ = new Error(this._statusText_);

        _error_._code_ = this._status_;

        reject(_error_);

```
      
```

```
    
```

```
    xhr
```

      reject(new Error("Network Error"));

```
    
```

```
    xhr
```

```
  
```

}

Как видно, внутри функции объект `XMLHttpRequest` создаётся и отсылается как обычно, при `onload/onerror` вызываются, соответственно, `resolve` (при статусе 200) или `reject`.

Использование:

httpGet("/article/promise/user.json")

```
  
```

```
    
```

```
    
```

```
  
```

**Метод** `**fetch**`

Заметим, что ряд современных браузеров уже поддерживает [fetch](https://learn.javascript.ru/fetch) – новый встроенный метод для AJAX-запросов, призванный заменить XMLHttpRequest. Он гораздо мощнее, чем `httpGet`. И – да, этот метод использует промисы. Полифил для него доступен на [https://github.com/github/fetch](https://github.com/github/fetch).

[Цепочки промисов](https://learn.javascript.ru/promise#tsepochki-promisov)

«Чейнинг» (chaining), то есть возможность строить асинхронные цепочки из промисов – пожалуй, основная причина, из-за которой существуют и активно используются промисы.

Например, мы хотим по очереди:

1.      Загрузить данные посетителя с сервера (асинхронно).

2.      Затем отправить запрос о нём на github (асинхронно).

3.      Когда это будет готово, вывести его github-аватар на экран (асинхронно).

4.      …И сделать код расширяемым, чтобы цепочку можно было легко продолжить.

Вот код для этого, использующий функцию `httpGet`, описанную выше:

'use strict';

// сделать запрос

httpGet('/article/promise/user.json')

  // 1. Получить данные о пользователе в JSON и передать дальше

```
  
```

```
    console
```

```
    
```

    return _user_;

```
  
```

  // 2. Получить информацию с github

```
  
```

```
    console
```

    return httpGet(`https://api.github.com/users/${user.name}`);

```
  
```

  // 3. Вывести аватар на 3 секунды (можно с анимацией)

```
  
```

```
    console
```

```
    githubUser 
```

```
    
```

```
    img
```

```
    img
```

```
    document
```

    setTimeout(() => _img_.remove(), 3000); // (*)

```
  
```

Самое главное в этом коде – последовательность вызовов:

httpGet(...)

```
  
```

```
  
```

```
  
```

При чейнинге, то есть последовательных вызовах `.then…then…then`, в каждый следующий `then` переходит результат от предыдущего. Вызовы `console.log` оставлены, чтобы при запуске можно было посмотреть конкретные значения, хотя они здесь и не очень важны.

**Если очередной** `**then**` **вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат.**

В коде выше:

1.      Функция в первом `then` возвращает «обычное» значение `user`. Это значит, что `then` возвратит промис в состоянии «выполнен» с `user` в качестве результата. Он станет аргументом в следующем `then`.

2.      Функция во втором `then` возвращает промис (результат нового вызова `httpGet`). Когда он будет завершён (может пройти какое-то время), то будет вызван следующий `then` с его результатом.

3.      Третий `then` ничего не возвращает.

Схематично его работу можно изобразить так:

Значком «песочные часы» помечены периоды ожидания, которых всего два: в исходном `httpGet` и в подвызове далее по цепочке.

Если `then` возвращает промис, то до его выполнения может пройти некоторое время, оставшаяся часть цепочки будет ждать.

То есть, логика довольно проста:

·         В каждом `then` мы получаем текущий результат работы.

·         Можно его обработать синхронно и вернуть результат (например, применить `JSON.parse`). Или же, если нужна асинхронная обработка – инициировать её и вернуть промис.

Обратим внимание, что последний `then` в нашем примере ничего не возвращает. Если мы хотим, чтобы после `setTimeout` `(*)` асинхронная цепочка могла быть продолжена, то последний `then` тоже должен вернуть промис. Это общее правило: если внутри `then` стартует новый асинхронный процесс, то для того, чтобы оставшаяся часть цепочки выполнилась после его окончания, мы должны вернуть промис.

В данном случае промис должен перейти в состояние «выполнен» после срабатывания `setTimeout`.

Строку `(*)` для этого нужно переписать так:

.then(githubUser => {

```
  
```

```
  
```

```
  
```

```
    
```

```
      img
```

```
      
```

```
      
```

```
      
```

      resolve();

```
    
```

```
  
```

})

Теперь, если к цепочке добавить ещё `then`, то он будет вызван после окончания `setTimeout`.

[Перехват ошибок](https://learn.javascript.ru/promise#perehvat-oshibok)

Выше мы рассмотрели «идеальный случай» выполнения, когда ошибок нет.

А что, если github не отвечает? Или JSON.parse бросил синтаксическую ошибку при обработке данных?

Да мало ли, где ошибка…

Правило здесь очень простое.

**При возникновении ошибки – она отправляется в ближайший обработчик** `**onRejected**`**.**

Такой обработчик нужно поставить через второй аргумент `.then(..., onRejected)` или, что то же самое, через `.catch(onRejected)`.

Чтобы поймать всевозможные ошибки, которые возникнут при загрузке и обработке данных, добавим `catch` в конец нашей цепочки:

'use strict';

// в httpGet обратимся к несуществующей странице

httpGet('/page-not-exists')

```
  
```

```
  
```

```
  
```

```
    githubUser 
```

```
    
```

```
    img
```

```
    img
```

```
    document
```

```
    
```

```
      
```

```
        img
```

```
        
```

```
      
```

```
    
```

```
  
```

  .catch(error => {

    alert(_error_); // Error: Not Found

  });

В примере выше ошибка возникает в первом же `httpGet`, но `catch` с тем же успехом поймал бы ошибку во втором `httpGet` или в `JSON.parse`.

Принцип очень похож на обычный `try..catch`: мы делаем асинхронную цепочку из `.then`, а затем, в том месте кода, где нужно перехватить ошибки, вызываем `.catch(onRejected)`.

**А что после** `**catch**`**?**

Обработчик `.catch(onRejected)` получает ошибку и должен обработать её.

Есть два варианта развития событий:

1.      Если ошибка не критичная, то `onRejected` возвращает значение через `return`, и управление переходит в ближайший `.then(onFulfilled)`.

2.      Если продолжить выполнение с такой ошибкой нельзя, то он делает `throw`, и тогда ошибка переходит в следующий ближайший `.catch(onRejected)`.

Это также похоже на обычный `try..catch` – в блоке `catch` ошибка либо обрабатывается, и тогда выполнение кода продолжается как обычно, либо он делает `throw`. Существенное отличие – в том, что промисы асинхронные, поэтому при отсутствии внешнего `.catch` ошибка не «вываливается» в консоль и не «убивает» скрипт.

Ведь возможно, что новый обработчик `.catch` будет добавлен в цепочку позже.

[Промисы в деталях](https://learn.javascript.ru/promise#promisy-v-detalyah)

Самым основным источником информации по промисам является, разумеется, [стандарт](https://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise-objects).

Чтобы наше понимание промисов было полным, и мы могли с лёгкостью разрешать сложные ситуации, посмотрим внимательнее, что такое промис и как он работает, но уже не в общих словах, а детально, в соответствии со стандартом ECMAScript.

Согласно стандарту, у объекта `new Promise(executor)` при создании есть четыре внутренних свойства:

·         `PromiseState` – состояние, вначале «pending».

·         `PromiseResult` – результат, при создании значения нет.

·         `PromiseFulfillReactions` – список функций-обработчиков успешного выполнения.

·         `PromiseRejectReactions` – список функций-обработчиков ошибки.

Когда функция-executor вызывает `reject` или `resolve`, то `PromiseState` становится `"resolved"` или `"rejected"`, а все функции-обработчики из соответствующего списка перемещаются в специальную системную очередь `"PromiseJobs"`.

Эта очередь автоматически выполняется, когда интерпретатору «нечего делать». Иначе говоря, все функции-обработчики выполнятся асинхронно, одна за другой, по завершении текущего кода, примерно как `setTimeout(..,0)`.

Исключение из этого правила – если `resolve` возвращает другой `Promise`. Тогда дальнейшее выполнение ожидает его результата (в очередь помещается специальная задача), и функции-обработчики выполняются уже с ним.

Добавляет обработчики в списки один метод: `.then(onResolved, onRejected)`. Метод `.catch(onRejected)` – всего лишь сокращённая запись `.then(null, onRejected)`.

Он делает следующее:

·         Если `PromiseState == "pending"`, то есть промис ещё не выполнен, то обработчики добавляются в соответствующие списки.

·         Иначе обработчики сразу помещаются в очередь на выполнение.

Здесь важно, что обработчики можно добавлять в любой момент. Можно до выполнения промиса (они подождут), а можно – после (выполнятся в ближайшее время, через асинхронную очередь).

Например:

// Промис выполнится сразу же

var `promise` = new Promise((resolve, reject) => resolve(1));

// PromiseState = "resolved"

// PromiseResult = 1

// Добавили обработчик к выполненному промису

```
promise
```

Разумеется, можно добавлять и много обработчиков на один и тот же промис:

// Промис выполнится сразу же

var `promise` = new Promise((resolve, reject) => resolve(1));

```
promise
```

  alert(_result_); // 1

```
  
```

})

```
promise
```

  alert(_result_); // 1

```
  
```

})

Вид объекта `promise` после этого:

На этой иллюстрации можно увидеть добавленные нами обработчики `f1`, `f2`, а также – автоматически добавленные обработчики ошибок `"Thrower"`.

Дело в том, что `.then`, если один из обработчиков не указан, добавляет его «от себя», следующим образом:

·         Для успешного выполнения – функция `Identity`, которая выглядит как `arg => arg`, то есть возвращает аргумент без изменений.

·         Для ошибки – функция `Thrower`, которая выглядит как `arg => throw arg`, то есть генерирует ошибку.

Это, по сути дела, формальность, но без неё некоторые особенности поведения промисов могут «не сойтись» в общую логику, поэтому мы упоминаем о ней здесь.

Обратим внимание, в этом примере намеренно _не используется чейнинг_. То есть, обработчики добавляются именно на один и тот же промис.

Поэтому оба `alert` выдадут одно значение `1`.

Все функции из списка обработчиков вызываются с результатом промиса, одна за другой. Никакой передачи результатов между обработчиками в рамках одного промиса нет, а сам результат промиса (`PromiseResult`) после установки не меняется.

Поэтому, чтобы продолжить работу с результатом, используется чейнинг.

**Для того, чтобы результат обработчика передать следующей функции,** `**.then**` **создаёт новый промис и возвращает его.**

В примере выше создаётся два таких промиса (т.к. два вызова `.then`), каждый из которых даёт свою ветку выполнения:

Изначально эти новые промисы – «пустые», они ждут. Когда в будущем выполнятся обработчики `f1, f2`, то их результат будет передан в новые промисы по стандартному принципу:

·         Если вернётся обычное значение (не промис), новый промис перейдёт в `"resolved"` с ним.

·         Если был `throw`, то новый промис перейдёт в состояние `"rejected"` с ошибкой.

·         Если вернётся промис, то используем его результат (он может быть как `resolved`, так и `rejected`).

Дальше выполнятся уже обработчики на новом промисе, и так далее.

Чтобы лучше понять происходящее, посмотрим на цепочку, которая получается в процессе написания кода для показа github-аватара.

Первый промис и обработка его результата:

httpGet('/article/promise/user.json')

```
  
```

Если промис завершился через `resolve`, то результат – в `JSON.parse`, если `reject` – то в Thrower.

Как было сказано выше, `Thrower` – это стандартная внутренняя функция, которая автоматически используется, если второй обработчик не указан.

Можно считать, что второй обработчик выглядит так:

httpGet('/article/promise/user.json')

```
  
```

Заметим, что когда обработчик в промисах делает `throw` – в данном случае, при ошибке запроса, то такая ошибка не «валит» скрипт и не выводится в консоли. Она просто будет передана в ближайший следующий обработчик `onRejected`.

Добавим в код ещё строку:

httpGet('/article/promise/user.json')

```
  
```

  .then(user => httpGet(`https://api.github.com/users/${user.name}`))

Цепочка «выросла вниз»:

Функция `JSON.parse` либо возвращает объект с данными, либо генерирует ошибку (что расценивается как `reject`).

Если всё хорошо, то `then(user => httpGet(…))` вернёт новый промис, на который стоят уже два обработчика:

httpGet('/article/promise/user.json')

```
  
```

```
  
```

```
  
```

    JSON._parse_,

    function avatarError(error) {

      if (_error_._code_ == 404) {

        return {_name_: "NoGithub", _avatar_url_: '/article/promise/anon.png'};

      } else {

        throw _error_;

      }

    }

```
  
```

Наконец-то хоть какая-то обработка ошибок!

Обработчик `avatarError` перехватит ошибки, которые были ранее. Функция `httpGet` при генерации ошибки записывает её HTTP-код в свойство `error.code`, так что мы легко можем понять – что это:

·         Если страница на Github не найдена – можно продолжить выполнение, используя «аватар по умолчанию»

·         Иначе – пробрасываем ошибку дальше.

Итого, после добавления оставшейся части цепочки, картина получается следующей:

'use strict';

httpGet('/article/promise/userNoGithub.json')

```
  
```

```
  
```

```
  
```

```
    
```

```
    
```

```
      
```

```
        
```

```
      
```

```
        
```

```
      
```

```
    
```

```
  
```

```
  
```

```
    
```

```
    img
```

```
    img
```

```
    document
```

```
    
```

```
  
```

```
  
```

```
    
```

```
  
```

В конце срабатывает общий обработчик `genericError`, который перехватывает любые ошибки. В данном случае ошибки, которые в него попадут, уже носят критический характер, что-то серьёзно не так. Чтобы посетитель не удивился отсутствию информации, мы показываем ему сообщение об этом.

Можно и как-то иначе вывести уведомление о проблеме, главное – не забыть обработать ошибки в конце. Если последнего `catch` не будет, а цепочка завершится с ошибкой, то посетитель об этом не узнает.

В консоли тоже ничего не будет, так как ошибка остаётся «внутри» промиса, ожидая добавления следующего обработчика `onRejected`, которому будет передана.

Итак, мы рассмотрели основные приёмы использования промисов. Далее – посмотрим некоторые полезные вспомогательные методы.

[Параллельное выполнение](https://learn.javascript.ru/promise#parallelnoe-vypolnenie)

Что, если мы хотим осуществить несколько асинхронных процессов одновременно и обработать их результат?

В классе `Promise` есть следующие статические методы.

[Promise.all(iterable)](https://learn.javascript.ru/promise#promise-all-iterable)

Вызов `Promise.all(iterable)` получает массив (или другой итерируемый объект) промисов и возвращает промис, который ждёт, пока все переданные промисы завершатся, и переходит в состояние «выполнено» с массивом их результатов.

Например:

```
Promise
```

```
  
```

```
  
```

]).then(results => {

```
  
```

});

Допустим, у нас есть массив с URL.

let `urls` = [

```
  
```

```
  
```

];

Чтобы загрузить их параллельно, нужно:

1.      Создать для каждого URL соответствующий промис.

2.      Обернуть массив таких промисов в `Promise.all`.

Получится так:

'use strict';

let `urls` = [

```
  
```

```
  
```

];

_Promise_.all( _urls_.map(_httpGet_) )

```
  
```

```
    
```

```
  
```

Заметим, что если какой-то из промисов завершился с ошибкой, то результатом `Promise.all` будет эта ошибка. При этом остальные промисы игнорируются.

Например:

```
Promise
```

```
  
```

```
  
```

```
  
```

]).then(

```
  
```

```
  
```

)

[Promise.race(iterable)](https://learn.javascript.ru/promise#promise-race-iterable)

Вызов `Promise.race`, как и `Promise.all`, получает итерируемый объект с промисами, которые нужно выполнить, и возвращает новый промис.

Но, в отличие от `Promise.all`, результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются.

Например:

```
Promise
```

```
  
```

```
  
```

]).then(firstResult => {

```
  firstResult 
```

```
  
```

});

[Promise.resolve(value)](https://learn.javascript.ru/promise#promise-resolve-value)

Вызов `Promise.resolve(value)` создаёт успешно выполнившийся промис с результатом `value`.

Он аналогичен конструкции:

new Promise((resolve) => resolve(`value`))

`Promise.resolve` используют, когда хотят построить асинхронную цепочку, и начальный результат уже есть.

Например:

```
Promise
```

```
  
```

```
  
```

[Promise.reject(error)](https://learn.javascript.ru/promise#promise-reject-error)

Аналогично `Promise.reject(error)` создаёт уже выполнившийся промис, но не с успешным результатом, а с ошибкой `error`.

Например:

```
Promise
```

```
  
```

Метод `Promise.reject` используется очень редко, гораздо реже чем `resolve`, потому что ошибка возникает обычно не в начале цепочки, а в процессе её выполнения.

[Итого](https://learn.javascript.ru/promise#itogo)

·         Промис – это специальный объект, который хранит своё состояние, текущий результат (если есть) и колбэки.

·         При создании `new Promise((resolve, reject) => ...)` автоматически запускается функция-аргумент, которая должна вызвать `resolve(result)` при успешном выполнении и `reject(error)` – при ошибке.

·         Аргумент `resolve/reject` (только первый, остальные игнорируются) передаётся обработчикам на этом промисе.

·         Обработчики назначаются вызовом `.then/catch`.

·         Для передачи результата от одного обработчика к другому используется чейнинг.

У промисов есть некоторые ограничения. В частности, стандарт не предусматривает какой-то метод для «отмены» промиса, хотя в ряде ситуаций (http-запросы) это было бы довольно удобно. Возможно, он появится в следующей версии стандарта JavaScript.

Некоторыми распространёнными полифилами являются `$.deferred`, Q и Bluebird, но не все они соответствуют спецификации. ES2015 поддерживает промисы "из коробки", и в настоящее время полифилы обычно не нужны.
