Подробнее:
[Отличия между стрелочными и обычными функциями](https://doka.guide/js/function/)
[5 отличий между стрелочными и обычными функциям](https://vc.ru/dev/133379-5-otlichiy-mezhdu-obychnymi-i-strelochnymi-funkciyami)

Стрелочная функция записывается намного короче, чем обычная. В самой простой записи ключевое слово `function` и фигурные скобки не требуются.

```
(argument1, argument2, ... argumentN) => {
  // тело функции
}
```

```
const add = (a, b) => a + b;
```

В многострочных стрелочных функциях кода больше, поэтому они имеют фигурные скобки, но в остальном не отличаются:
~~~
const divider = (numerator, denominator) => 
{   const result = numerator / denominator   
return result }`
~~~

##### 1 this
Внутри обыкновенной функции значение _this_ динамическое (в зависимости от контекста исполнения), во время выполнения функции объектом значения _this_ является объект, у которого был вызван метод.

##### 2 Конструкторы
Как следствие того, что стрелочные функции не имеют собственного _this_ они не могут быть использованы для создания объектов. Если попытаться вызвать стрелочную функцию с использованием ключевого слова _new_, JS кинет исключение:
~~~
const Car = (color) => { 
this.color = color; }; 
const redCar = new Car('red'); // TypeError: Car is not a constructor
~~~

##### 3 Неявный return

Ты можешь вернуть значение из стрелочной функции, точно таким же способом, как и из обычной функции, но с одним полезным исключением.

Если стрелочная функция содержит в теле одну инструкцию, и ты опустил фигурные скобки, тогда выражение будет возвращено автоматически.
~~~
const increment = (num) => num + 1; 
increment(41); // => 42
~~~

##### 4 Методы

Ты можешь использовать стрелочные функции как методы, внутри класса.
Сейчас, на контрасте с обыкновенной функцией, метод определенный с использованием стрелочной функции привязывает this к объекту класса.

## [[003 JSCore|Назад]]