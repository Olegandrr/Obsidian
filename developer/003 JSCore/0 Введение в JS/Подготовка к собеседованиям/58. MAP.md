# 58. MAP

Довольно часто нам нужно модифицировать каждый элемент массива, используя один и тот же подход. Типичный пример - возвести каждый элемент массива чисел в квадрат, получить имя из списка пользователей или обработать строки регулярным выражением.

`map` является встроенным методом, который делает как раз то что мы хотим. Данный метод определён в `Array.prototype`, следовательно его можно вызвать на любом массиве, после чего передать каллбек в качестве первого аргумента.

Когда вы вызываете `map` для массива, каллбек выполняется для каждого элемента данного массива, затем возвращается _новый_ массив со значениями обработанными каллбеком.

Под капотом, `map` передаёт три аргумента каллбеку:

1. _Текущий элемент_ массива
2. _Индекс в массиве_ текущего элемента
3. _Весь массив_ для которого был вызван map

Давайте взглянем на код.

`map` на практике

Предположим у нас есть приложение, в котором содержится массив всех задач, которые стоит выполнить в течении дня. Каждый `task` является объектом, у которого есть свойства `name` и `duration`:

|   |   |
|---|---|
|1|// Durations are in minutes|
|2||
|3|**var** tasks = [|
|4||
|5|{|
|6||
|7|'name'     : 'Write for Envato Tuts+',|
|8||
|9|'duration' : **120**|
|10||
|11|},|
|12||
|13|{|
|14||
|15|'name'     : 'Work out',|
|16||
|17|'duration' : **60**|
|18||
|19|},|
|20||
|21|{|
|22||
|23|'name'     : 'Procrastinate on Duolingo',|
|24||
|25|'duration' : **240**|
|26||
|27|}|
|28||
|29|];|

Возможно мы хотим создать новый массив только с name для каждого task, что в свою очередь позволит нам взглянуть на всё задачи, которые мы выполнили на сегодня. Используя цикл `for`, мы бы написали что-то, что выглядит следующим образом:

|   |   |
|---|---|
|1|**var** task_names = [];|
|2||
|3|**for** (**var** i = **0**, max = tasks.length; i < max; i += **1**) {|
|4||
|5|task_names.push(tasks[i].name);|
|6||
|7|}|

JavaScript также предоставляет нам цикл `forEach`. Он работает примерно также как и цикл `for`, но нам не нужно сравнивать индекс элемента с длинной массива, всё это делается за нас:

|   |   |
|---|---|
|1|var task_names = [];|
|2||
|3|tasks.forEach(function (task) {|
|4||
|5|task_names.push(task.name);|
|6||
|7|});|

Используя `map`, мы можем написать:

|   |   |
|---|---|
|1|**var** task_names = tasks.map(**function** (task, index, array) {|
|2||
|3|**return** task.name;|
|4||
|5|});|

Я добавил `index` и `array` параметры, чтобы вы не забывали, что мы можем ими воспользоваться, если это необходимо. Так как в примере я их не использую, можно их убрать и код будет продолжать работать.

Есть два важных отличия между этими двумя подходами:

1. Используя `map`, вам не придётся управлять состоянием цикла `for` самостоятельно.
2. Вы можете взаимодействовать с элементами напрямую, вместо индексирования массива.
3. Вам не придётся создавать новый массив и добавлять (`push`) элементы в него. `map` возвращает конечный результат за один подход, нам остаётся лишь добавить возвращаемое значение новой переменной.
4. Не забывайте _добавить_ `return` вашему каллбеку. Если этого не сделать, мы получим новый массив заполненный `undefined`.

_Всё_ функции, которые мы будем разбирать сегодня обладают теми же характеристиками.

Факт того, что нам в ручную не нужно управлять состоянием цикла, делает наш код проще и его легче поддерживать. А также факт того, что можно взаимодействовать с каждым элементом напрямую, вместо индексирования массива, делает код более читабельным.

Использование цикла `forEach` решает обе проблемы. Но у `map` всё равно есть по крайней мере два преимущества:

1. `forEach` возвращает `undefined`, поэтому его нельзя связать с другими методами массива. `map` возвращает массив, тем самым мы _можем_ связывать его с другими методами массива.
2. `map` возвращает массив с конечным результатом, нам не приходится изменять массив внутри цикла.

Обладая несколькими местами где состояние модифицируется по минимуму, важный принцип функционального программирования. Код становится более безопасным и понятным.

Пришло время упомянуть, если вы используете Node, тестируете примеры в консоли браузера Firefox или используете [**Babel**](https://babeljs.io/) или [**Traceur**](https://github.com/google/traceur-compiler), можно писать короткую стрелочную функцию из ES6:

|   |   |
|---|---|
|1|**var** task_names = tasks.map((task) => task.name );|

Со стрелочной функцией нет необходимости использовать `return`, вся функция помещается на одной строке.

Пожалуй более читабельный результат получить нельзя.

Подводные камни

В каллбеке передаваемом `map` должен быть явный `return` или `map` возвратит массив заполненный `undefined`. Не так сложно запомнить что мы должны возвращать (`return`) значение, но в свою очередь можно и забыть об этом.

Если вы _забудете_ об этом, `map` не покажет ошибок. Вместо этого, будет возвращён пустой массив. Такие тихие ошибки на удивление сложно искать.

К счастью данный подводный камень относится _только_ к `map`. Но это часто встречаемая ошибка, на которой я должен заострить внимание: Всегда добавляйте `return` в ваши каллбеки!
