# 2. Объясните, как this работает в JavaScript

Использование this гарантирует, что функция работает именно с тем объектом, в контексте которого вызвана, если это не стрелочная функция. У стрелочных функций контекст this определяется в момент создания функции.

Значение this называется контекстом вызова и будет определено в момент вызова функции. Значением this является объект перед точкой, в контексте которого вызван метод.

Как правило, методу объекта обычно требуется доступ к информации, хранящейся в объекте, для выполнения своей работы.

Например, коду внутри user.sayHi() может потребоваться имя пользователя, которое хранится в объекте user.

**Для доступа к информации внутри объекта метод может использовать ключевое слово this.**

Значение this – это объект «перед точкой», который используется для вызова метода.

Например:

let user = {

  name: "John",

  age: 30,

  sayHi() {

    // "this" - это "текущий объект".

    alert(this.name);

  }

};

user.sayHi(); // John

Здесь во время выполнения кода user.sayHi() значением this будет являться user (ссылка на объект user).

Технически также возможно получить доступ к объекту без ключевого слова this, обратившись к нему через внешнюю переменную (в которой хранится ссылка на этот объект):

let user = {

  name: "John",

  age: 30,

  sayHi() {

    alert(user.name); // "user" вместо "this"

  }

};

…Но такой код ненадёжен. Если мы решим скопировать ссылку на объект user в другую переменную, например, admin = user, и перезапишем переменную user чем-то другим, тогда будет осуществлён доступ к неправильному объекту при вызове метода из admin.

Это показано ниже:

let user = {

  name: "John",

  age: 30,

  sayHi() {

    alert( user.name ); // приведёт к ошибке

  }

};

let admin = user;

user = null; // перезапишем переменную для наглядности, теперь она не хранит ссылку на объект.

admin.sayHi(); // TypeError: Cannot read property 'name' of null

Если бы мы использовали this.name вместо user.name внутри alert, тогда этот код бы сработал.

В JavaScript ключевое слово «this» ведёт себя иначе, чем в большинстве других языков программирования. Его можно использовать в любой функции, даже если это не метод объекта.

В следующем примере нет синтаксической ошибки:

function sayHi() {

  alert( this.name );

}

Значение this вычисляется во время выполнения кода, в зависимости от контекста.

Например, здесь одна и та же функция назначена двум разным объектам и имеет различное значение «this» в вызовах:

let user = { name: "John" };

let admin = { name: "Admin" };

function sayHi() {

  alert( this.name );

}

// используем одну и ту же функцию в двух объектах

user.f = sayHi;

admin.f = sayHi;

// эти вызовы имеют  разное значение this

// "this" внутри функции - это объект "перед точкой"

user.f(); // John  (this == user)

admin.f(); // Admin  (this == admin)

admin['f'](); // Admin (нет разницы между использованием точки или квадратных скобок для доступа к объекту)

Правило простое: если вызывается obj.f(), то во время вызова f, this – это obj. Так что, в приведённом выше примере это либо user, либо admin.

Стрелочные функции особенные: у них нет своего «собственного» `this`. Если мы ссылаемся на `this` внутри такой функции, то оно берётся из внешней «нормальной» функции.

Например, здесь `arrow()` использует значение `this` из внешнего метода `user.sayHi()`:

let `user` = {

```
  firstName
```

```
  
```

```
    
```

```
    
```

```
  
```

};

```
user
```

Это особенность стрелочных функций. Она полезна, когда мы на самом деле не хотим иметь отдельное `this`, а скорее хотим взять его из внешнего контекста. Позже в главе [Повторяем стрелочные функции](https://learn.javascript.ru/arrow-functions) мы увидим больше примеров на эту тему.

[Итого](https://learn.javascript.ru/object-methods#itogo)

·         Функции, которые находятся в свойствах объекта, называются «методами».

·         Методы позволяют объектам «действовать»: `object.doSomething()`.

·         Методы могут ссылаться на объект через `this`.

Значение `this` определяется во время исполнения кода.

·         При объявлении любой функции в ней можно использовать `this`, но этот `this` не имеет значения до тех пор, пока функция не будет вызвана.

·         Функция может быть скопирована между объектами (из одного объекта в другой).

·         Когда функция вызывается синтаксисом «метода» – `object.method()`, значением `this` во время вызова является `object`.

Также ещё раз заметим, что стрелочные функции являются особенными – у них нет `this`. Когда внутри стрелочной функции обращаются к `this`, то его значение берётся извне.
