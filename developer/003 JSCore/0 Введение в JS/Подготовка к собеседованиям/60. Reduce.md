# 60. Reduce

`map` создаёт новый массив, меняя каждый элемент массива индивидуально. `filter` создаёт новый массив убирая элементы, которые не соответствуют условиям. `reduce` в свою очередь, берёт все элементы в массиве, складывает их в новое значение.

Также как `map` и `filter`, `reduce` определяется в `Array.prototype` и также доступен для любого массива, и вы передаёте каллбек в качестве первого аргумента. Помимо этого можно передать необязательный второй аргумент: значение, индекс с которого стоит начать складывать элементы вашего массива.

`reduce` передаёт каллбеку четыре аргумента:

1. Текущее значение
2. Предыдущее значение
3. Текущий индекс
4. _Массив_, для которого вы вызываете `reduce`

Обратите внимание, что каллбек имеет доступ к _предыдущему_ значению на каждой итерации. На первой интерации предыдущего значения _нет_. Вот почему у вас есть выбор передать `reduce` начальное значение: данное значение и будет "предыдущим значением" при первой итерации, и как я уже упоминал в противном случае предыдущее значение будет равно нулю.

Наконец, запомните, что `reduce` возвращает одно значение, _не_ массив содержащий один элемент. Это важнее, чем может показаться на первый взгляд и я вернусь к этому моменту во время разбора нашего примера.

`reduce` на практике

Так как `reduce` функция, которая поначалу многим может показаться слегка непонятной, мы начнём, шаг за шагом разбирать что-то более простое.

Давайте предположим, что мы хотим найти сумму списка чисел. Используя цикл, это будет выглядеть следующим образом:

|   |   |
|---|---|
|1|**var** numbers = [**1**, **2**, **3**, **4**, **5**],|
|2|total = **0**;|
|3||
|4|numbers.forEach(**function** (number) {|
|5|total += number;|
|6|});|

Несмотря на то что это неплохой случай воспользоваться `forEach`, `reduce` всё равно имеет преимущество, применяя его мы избегаем мутаций. С `reduce` мы напишем следующий код:

|   |   |
|---|---|
|1|**var** total = [**1**, **2**, **3**, **4**, **5**].reduce(**function** (previous, current) {|
|2|**return** previous + current;|
|3|}, **0**);|

Для начала, мы вызовем `reduce` для нашего списка чисел (`numbers`). Мы передадим его каллбеку, который принимает предыдущее значение и текущее значение в качестве аргументов и вернём результат сложения их вместе. Так как мы передали `0` в качестве второго аргумента `reduce`, 0 будет использоваться, как предыдущее (`previous`) значение при первой итерации.

Взглянем, как это работает шаг за шагом:

|**Итерация**|**Предыдущее**|**Текущее**|**Общее**|
|---|---|---|---|
|1|0|1|1|
|2|1|2|3|
|3|3|3|6|
|4|6|4|10|
|5|10|5|15|

Если вы не любитель таблиц, запустите этот кусочек кода в консоли:

|   |   |
|---|---|
|1|**var** total = [**1**, **2**, **3**, **4**, **5**].reduce(**function** (previous, current, index) {|
|2|**var** val = previous + current;|
|3|console.log("The previous value is " + previous +|
|4|"; the current value is " + current +|
|5|", and the current iteration is " + (index + **1**));|
|6|**return** val;|
|7|}, **0**);|
|8||
|9|console.log("The loop is done, and the final value is " + total + ".");|

Напомню: `reduce` складывает все элементы массива на каждой интерации, комбинируя их таким образом, как вы укажете в каллбеке. При каждой итерации, каллбек имеет доступ к _предыдущему значению_, которое на данный момент равно _общему значению_ или _аккумулированному значению_; также как к _текущему значению_; _текущему индексу_ и _всему массиву_, если они нужны вам.

Давайте вернёмся к примеру с приложением для задач на день. Мы получили список названий задач благодаря `map` и отфильтровали список используя `filter`.

Что если вы хотите узнать общее количество времени, которое было затрачено на работу, сегодня?;

Используя цикл `forEach` решение будет выглядеть следующим образом:

|   |   |
|---|---|
|1|var total_time = 0;|
|2||
|3|tasks.forEach(function (task) {|
|4|// The plus sign just coerces|
|5|// task.duration from a String to a Number|
|6|total_time += (+task.duration);|
|7|});|

Решение с `reduce`:

|   |   |
|---|---|
|1|var total_time = tasks.reduce(function (previous, current) {|
|2|return previous + current;|
|3|}, 0);|
|4||
|5|// Using arrow functions|
|6|var total_time = tasks.reduce((previous, current) previous + current );|

Просто.

На этом почти всё. Почти, потому что JavaScript предоставляет малоизвестный метод, под названием `reduceRight`. В примере выше, `reduce` начинает с _первого_ элемента массива, затем процесс итерации проходит слева направо:

|   |   |
|---|---|
|1|**var** array_of_arrays = [[**1**, **2**], [**3**, **4**], [**5**, **6**]];|
|2|**var** concatenated = array_of_arrays.reduce( **function** (previous, current) {|
|3|**return** previous.concat(current);|
|4|});|
|5||
|6|console.log(concatenated); // [1, 2, 3, 4, 5, 6];|

`reduceRight` делает тоже самое, но в противоположном направлении:

|   |   |
|---|---|
|1|var array_of_arrays = [[1, 2], [3, 4], [5, 6]];|
|2|var concatenated = array_of_arrays.reduceRight( function (previous, current) {|
|3|return previous.concat(current);|
|4|});|
|5||
|6|console.log(concatenated); // [5, 6, 3, 4, 1, 2];|

Я использую `reduce` каждый день, но у меня никогда не было необходимости использовать `reduceRight`. Думаю вам он также не пригодится. Однако, на тот случай если данный метод вам понадобится, не забывайте, что он существует.

Подводные камни

Три огромных подводный камня с `reduce`:

1. Забыли `return`
2. Забыли начальное значение
3. Ожидать, что `reduce` вернёт массив, когда он возвращает одно значение

К счастью первые два пункта легко избежать. Начальное значение зависит от того, что вы пытаетесь сделать, но вы быстро к этому привыкните.

Последний пункт может показаться немного странным. Если `reduce` возвращает одно значение, почему вы будете ждать в качестве результата массив?

На то есть две причины. Для начала, `reduce` всегда возвращает одно _значение_, не всегда это значение является _числом_. К примеру если вы обрабатываете reduce'ом массив содержащий массивы, возвратится один массив. Если у вас привычка обрабатывать reduce'ом массивы, справедливо ожидать, что массив содержащий один элемент будет исключительным случаем.

Во вторых, если `reduce` _возвратит_ массив с одним единственным значением, он будет отлично взаимодействовать с `map` и `filter`, а также другими функциями массивов, которые можно использовать.
