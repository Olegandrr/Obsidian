## 12 В чем разница между state и props

State - очень похоже на уже знакомые нам пропсы, отличие в том, что состояние контролируется и доступно только конкретному компоненту. Объект **state** описывает внутреннее состояние компонента, он похож на props за тем исключением, что состояние определяется внутри компонента и доступно только из компонента.

Также в отличие от props значения в state можно изменять.

`setState()`

setState(`updater`[, `callback`])

`setState()` добавляет в очередь изменения в состоянии компонента. Также он указывает React, что компонент и его дочерние элементы должны быть повторно отрендерены с обновлённым состоянием. Этот метод используется для обновления интерфейса в ответ на обработчики событий и ответы сервера.

Думайте о `setState()`, как о _запросе_, а не как о команде немедленного обновления компонента. Для увеличения производительности React может задержать его выполнение, а затем обновить несколько компонентов за один проход. In the rare case that you need to force the DOM update to be applied synchronously, you may wrap it in [`flushSync`](https://ru.reactjs.org/docs/react-dom.html#flushsync), but this may hurt performance.

Метод `setState()` не всегда обновляет компонент сразу. Он может группировать или откладывать обновление до следующего раза. Это делает чтение `this.state` сразу после вызова `setState()` потенциальной ловушкой. Вместо этого используйте `componentDidUpdate()` или колбэк `setState()` (`setState(updater, callback)`), каждый из которых гарантированно вызывается после того как было применено обновление. Если вам нужно обновить состояние на основе предыдущего, используйте аргумент `updater`, описанный ниже.

`setState()` всегда приводит к повторному рендеру, если только `shouldComponentUpdate()` не возвращает `false`. Если используются мутабельные объекты, и условие рендеринга не может быть реализовано в `shouldComponentUpdate()`, вызывайте `setState()` только при разнице следующего и предыдущего состояния. Это предотвратит ненужные повторные рендеры.

Первым аргументом передаётся функция `updater`, которая имеет следующий вид:

(state, props) => `stateChange`

`state` — ссылка на состояние компонента при изменении. Объект состояния не должен мутировать. Изменения должны проявляться в виде нового объекта на основе входных данных из `state` и `props`. Предположим, что мы хотели бы увеличить значение состояния с помощью `props.step`:

this.setState((state, props) => {

```
  
```

});

Как `state`, так и `props`, полученные функцией обновления, гарантированно будут обновлены. Результат функции поверхностно объединяется с `state`.

Второй параметр в `setState()` — необязательный колбэк, вызываемый после выполнения `setState` и повторного рендера компонента. Вместо этого в большинстве случаев для такой логики мы рекомендуем использовать `componentDidUpdate()`.

В качестве первого аргумента `setState()`, вместо функции, вы можете передать объект:

setState(`stateChange`[, `callback`])

В нём образуется новое состояние после поверхностного объединения с `stateChange`. Например, установим количество товаров в корзине:

this.setState({quantity: 2})

Эта форма записи `setState()` также асинхронна, и несколько вызовов в течение одного цикла могут быть объединены вместе. Например, вам нужно увеличить количество элементов несколько раз в одном цикле. Результат этого можно представить так:

```
Object
```

```
  previousState
```

```
  
```

```
  
```

```
  
```

)

Последующие вызовы будут переопределять значения из предыдущих вызовов того же цикла. Из-за этого количество увеличится только один раз. В случае, если следующее состояние зависит от текущего, мы рекомендуем использовать форму функции обновления:

this.setState((state) => {

```
  
```

});

**//////////////////////////////////////////////////////////////////////**

**const** App = () => {

  **const** [state, setState] = useState(0);

  _// используем тогда, когда нужно установить значенее, которое не зависит от state_

  setState(1);

  setState((prevState) => {

    **return** prevState + 1;

    _// мы могли б написать return state + 1,_

    _// но тогда б мы не были б уверены, что там именно прошлый state (возможно, он еще не обновился)_

  });

};

И еще важный момент - значения из state должны использоваться при рендеринге. Если какой-то объект не используется в рендерниге компонента, то нет смысла сохранять его в state.

[props](https://ru.reactjs.org/docs/components-and-props.html) (намеренно сокращённо от англ. «properties» — свойства) и [state](https://ru.reactjs.org/docs/state-and-lifecycle.html) — это обычные JavaScript-объекты. Несмотря на то, что оба содержат информацию, которая влияет на то, что увидим после рендера, есть существенное различие: props передаётся _в_ компонент (служат как параметры функции), в то время как state находится _внутри_ компонента (по аналогии с переменными, которые объявлены внутри функции).
