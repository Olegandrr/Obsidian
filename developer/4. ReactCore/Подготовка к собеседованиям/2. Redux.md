# 2. Redux

  
  

## 2.1 createStore

  
Когда вы создали базовую структуру для работы с хранилищем Redux пришло время понять то как вы можете взаимодействовать с ним.  
  
Глобальное хранилище приложения создаётся в отдельном файле, который как правило называется store.js:  
  
  

// Код файла store.js

**import** `{ createStore }` **from** 'redux'`;`

**const** `store = createStore(reducer);`

**export** **default** `store;`

  
  

### **2.2 reducer()**

  
reducer — чистая функция которая будет отвечать за обновление состояния. Здесь реализовывается логика в соответствие с которой будет происходить обновление полей store.  
  
Так выглядит базовая функция reducer:  
  
  

**function** **reducer**(state, action) `{`

    **switch**`(action.type) {`

        **case** `ACTION_1:` **return** `{` value`: action.value_1 };`

        **case** `ACTION_2:` **return** `{` value`: action.value_2 };`

        **default**`:` **return** `state;`

    `}`

`}`

  
Функция принимает значение текущего состояния и обьект события (action). Обьект события содержит два свойства — это тип события (action.type) и значение события (action.value).  
  
К примеру если нужно обработать событие onChange для поля ввода то объект события может выглядеть так:  
  
  

`{`

    `type:` "ACTION_1"`,`

    `value:` "Здесь значение поля формы"

`}`

Некоторые события могут не нуждаться в передаче каких-либо значении. К примеру, обрабатывая событие onClick мы можем сигнализировать о том, что событие произошло, более никаких данных не требуется, а как на него реагировать будет описывать логика, заложенная непосредственно в сам компонент которой должен на него реагировать и частично в reducer. Но во всех случаях необходимо определять тип события. Редьюсер как бы спрашивает: что произошло? actio.type равен «ACTION_1» ага значит произошло событие номер 1. Дальше его нужно как то обработать и обновить состояние. То, что вернёт редьюсер и будет новым состоянием.  
  
ACTION_1 и ACTION_2 это константы событий. По-другому Actions. Про них мы поговорим далее [2.5 Actions](#025).  
  
Как вы уже догадались store может хранить сложную структуру данных состоящих из набора независимых свойств. Обновление одного свойства оставит нетронутым другие свойства. Так из примера выше, когда происходит событие номер один (ACTION_1) обновляется поле номер один (value_1) в store при этом поле номер два (value_2) остаётся нетронутым. В общем механизм схож с методом this.setState().  
  
  

### **2.3 dispatch()**

  
Что бы обновить store необходимо вызвать метод dispatch(). Он вызывается у объекта store который вы создаёте в store.js. Этот объект принято называть store поэтому обновление состояния в моём случае выглядит так:  
  
  

`store.dispatch({` type`: ACTION_1,` value_1`:` "Some text" `});`

ACTION_1 это константа события о которой речь пойдет дальше (см. [Actions](https://habr.com/ru/post/498860/#025)).  
  
Эта функция вызовет функцию reducer который обработает событие и обновит соответствующие поля хранилища.  
  
  

### **2.4 actionCreator()**

  
На самом деле передавать объект события напрямую в dispatch() является признаком плохого тона. Для этого нужно использовать функцию под названием actionCreator. Она делает ровно то что и ожидается. Создаёт событие! Вызов этой функции нужно передавать как аргумент в dispatch а в actionCreator передавать необходимое значение (value). Базовый actionCreator выглядит следующим образом:  
  
  

**function** **action_1**(value) `{`

    **return** `{` 

        type`: ACTION_1,`

        value_1`: value`

    `};`

`}`

**export** **default** `action_1;`

  
Таким образом вызов dispatch должен выглядеть так:  
  
  

`store.dispatch(action_1(`"Some value"`));`

  
С использованием actionCreator код становится более чистым.  
  
  

### **2.5 Actions**

  
actions это константы, описывающие событие. Обычно это просто строка с названием описывающее событие. К примеру константа описывающее событие номер один будет выглядеть следующем образом:  
  
  

**const** `ACTION_1 =` "ACTION_1"`;`

**export** **default** `ACTION_1;`

  
Опять же в проекте вам стоит называть константы в соответствии с событием, которое она описывает: onClick, createUserSesion, deleteItem, addItem и т.д. Главное, чтобы было понятно. Замете что я нигде не писал import поэтому не забудьте импортировать ваши константы перед их использованием. Потому что константы тоже принято разбивать на отдельные файлы храня их в специальной папке. Хотя некоторые хранят их в одном файле под названием actionTypes.js. Такое решение нельзя назвать не правильным, но и не идеальным.  
  
  

### **2.6 getState()**

  
С помощью dispatch() обновили, а как теперь посмотреть новое значение store? Ничего изобретать не нужно, есть метод getState(). Он также, как и метод dispatch вызывается на экземпляре объекта store. Поэтому для моего примера вызов  
  
  

`store.getState()`

  
вернёт значение полей хранилища. К примеру что бы посмотреть значение поля value_1 необходимо будет вызвать  
  
  

`store.getState().value_1`

  
  

### **2.7 subscribe()**

  
А как же узнать, когда состояние обновилось? Для этого есть метод subscribe(). Он также вызывается на экземпляре store. Данный метод принимает функцию, которая будет вызывается каждый раз после обновления store. Он как бы «подписывает» функцию, переданную ему на обновление. К примеру следующий код при каждом обновлении (при каждом вызове dispatch()) будет выводить новое значение store в консоль.  
  
  

`store.subscribe(`() => console`.info(store.getState()))`

  
Этот метод возвращает функцию unsubscribe(). Которая позволяет «отписаться от обновления». К примеру если компонент удаляется из DOM стоит отписать его методы от обновления в componentWillUnmount(). Этот метод жизненного цикла вызывается при размонтировании компонента и это именно то место где стоит отписываться от обновления. Проще говоря в деструкторе.  
  
  

### **2.8 combineReducers()**

  
combineReducers() позволяет объединить несколько редьюсеров в один.  
  
Если логика обновления компонентов довольно сложна и\или необходимо обрабатывать большое количество различных типов событий, то корневой reducer может стать слишком громоздким. Лучшим решением будет разбить его на несколько отдельных редьюсеров каждый из которых отвечает за обработку только одного типа событий и обновления определённого поля.  
  
**Внимание!**  
  

Когда вы разбиваете базовый редьюсер на несколько, то название каждого из них должно соответствовать полю которое он обновляет в store.

К примеру если редьюсер обновляет поле номер один, то он может выглядеть так:  
  
  

**function** **value_1**(state, action) `{`

    **switch**`(action.type) {`

        **case** `ACTION_1:` **return** `action.value_1;`

        **default**`:` **return** `state;`

    `}`

`}`

**export** **default** `value_1;`

  
Название редьюсера (value_1) показывает какое свойство он будет обновлять в store. Если переименуете его в value_2 то он станет обновлять value_2. Поэтому учтите это!  
  
Когда используется единый редьюсер мы показываем какое поле хотим обновить:  
  
  

 **case** `ACTION_1:` **return** `{` value_1`: action.value_1 };`

  
Но когда вы разделили ваши редьюсеры вам нужно просто вернуть новое значение:  
  
  

**case** `ACTION_1:` **return** `action.value_1;`

  
Поскольку здесь не требуется указывать которое из полей обновляет редьюсер ибо его название и есть поле которое он обновляет.  
  
  

### **2.9 initialState**

  
initialState — объект, представляющий начальное состояние хранилища. Он является вторым не обязательным аргументом метода createStore(). С созданием хранилища можно сразу объявить начальное состояние для его полей. Этот объект желательно создавать, даже в тех случаях, когда объявления начального состояния не требуется. Потому что этот объект помогает посмотреть на структуру хранилища и название его полей. Обычный объект initialState выглядит следующим образом:  
  
  

**const** `initialState = {`

    date_1`:` "value..."`,`

    date_2`:` "value..."

`};`

**export** **default** `initialState;`

  
В некоторых случаях (когда компонент сразу использует значение из store), его объявление может стать обязательным иначе вы получите ошибку: TypeError: Cannot read property 'value_1' of undefined.  
  
Также редьюсеры всегда должны возвращать по дефолту текущее состояние. К примеру, если используется единый reducer то последнее значение в switch должно выглядеть так:  
  
  

**default**`:` **return** `store;`

  
Если же вы разделяете редьюсеры на независимые функции, то он должен возвращать значение того свойства за которое он отвечает:  
  
  

**default**`:` **return** `store.value_1;`

  
Также если вы не передаёте объект initialState в createStore вы можете вернуть его из редьюсера. В обоих случаях будет инициализировано начальное состояние для store.
