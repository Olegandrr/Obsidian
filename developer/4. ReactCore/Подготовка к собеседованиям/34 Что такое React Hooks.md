## 34 Что такое React Hooks

Функционал, добавленный в React 16.8. С помощью хуков, можно писать приложения, используя только функциональные компоненты, без классов.

С помощью хуков можно следить за стейтом, эмулировать жизненные этапы компонента, работа с ссылками и многое другое

UseState() - const [`state`, `setState`] = useState(`initialState`);

Возвращает значение с состоянием и функцию для его обновления.

Во время первоначального рендеринга возвращаемое состояние (`state`) совпадает со значением, переданным в качестве первого аргумента (`initialState`).

Функция `setState` используется для обновления состояния. Она принимает новое значение состояния и ставит в очередь повторный рендер компонента.

setState(`newState`);

Во время последующих повторных рендеров первое значение, возвращаемое `useState`, всегда будет самым последним состоянием после применения обновлений.

UseEffect() - useEffect(`didUpdate`);

Принимает функцию, которая содержит императивный код, возможно, с эффектами.

Мутации, подписки, таймеры, логирование и другие побочные эффекты не допускаются внутри основного тела функционального компонента (называемого _этапом рендеринга_ React). Это приведёт к запутанным ошибкам и несоответствиям в пользовательском интерфейсе.

Вместо этого используйте `useEffect`. Функция, переданная в `useEffect`, будет запущена после того, как рендер будет зафиксирован на экране. Думайте об эффектах как о лазейке из чисто функционального мира React в мир императивов.

Часто эффекты создают ресурсы, которые необходимо очистить (или сбросить) перед тем, как компонент покидает экран, например подписку или идентификатор таймера. Чтобы сделать это, функция переданная в `useEffect`, может вернуть функцию очистки. Например, чтобы создать подписку:

useEffect(() => {

```
  
```

```
  
```

```
    
```

```
    subscription
```

```
  
```

});

Функция очистки запускается до удаления компонента из пользовательского интерфейса, чтобы предотвратить утечки памяти. Кроме того, если компонент рендерится несколько раз (как обычно происходит), **предыдущий эффект очищается перед выполнением следующего эффекта**. В нашем примере это означает, что новая подписка создаётся при каждом обновлении. 

UseContext()const `value` = useContext(`MyContext`);

Принимает объект контекста (значение, возвращённое из `React.createContext`) и возвращает текущее значение контекста для этого контекста. Текущее значение контекста определяется пропом `value` ближайшего `<MyContext.Provider>` над вызывающим компонентом в дереве.

Когда ближайший `<MyContext.Provider>` над компонентом обновляется, этот хук вызовет повторный рендер с последним значением контекста, переданным этому провайдеру `MyContext`. Даже если родительский компонент использует [`React.memo`](https://ru.reactjs.org/docs/react-api.html#reactmemo) или реализует [`shouldComponentUpdate`](https://ru.reactjs.org/docs/react-component.html#shouldcomponentupdate), то повторный рендер будет выполняться, начиная c компонента, использующего `useContext`.

Запомните, аргументом для `useContext` должен быть _непосредственно сам объект контекста_:

·         **Правильно:** `useContext(MyContext)`

·         **Неправильно:** `useContext(MyContext.Consumer)`

·         **Неправильно:** `useContext(MyContext.Provider)`

Компонент, вызывающий `useContext`, всегда будет перерендериваться при изменении значения контекста. Если повторный рендер компонента затратен, вы можете [оптимизировать его с помощью мемоизации](https://github.com/facebook/react/issues/15156#issuecomment-474590693).

UseRef()const `refContainer` = useRef(`initialValue`);

`useRef` возвращает изменяемый ref-объект, свойство `.current` которого инициализируется переданным аргументом (`initialValue`). Возвращённый объект будет сохраняться в течение всего времени жизни компонента.

Обычный случай использования — это доступ к потомку в императивном стиле:

function TextInputWithFocusButton() {

```
  
```

```
  
```

```
    
```

```
    inputEl
```

```
  
```

```
  
```

```
    
```

      <input ref={inputEl} type="text" />

      <button onClick={onButtonClick}>Установить фокус на поле ввода</button>

    </>

```
  
```

}

По сути, `useRef` похож на «коробку», которая может содержать изменяемое значение в своём свойстве `.current`.

Возможно, вы знакомы с рефами в основном как со способом [получить доступ к DOM](https://ru.reactjs.org/docs/refs-and-the-dom.html). Если вы передадите React объект рефа с помощью подобного выражения `<div ref={myRef}/>`, React установит собственное свойство `.current` на соответствующий DOM-узел при каждом его изменении.

Но хук `useRef()` полезен не только установкой атрибута с рефом. Он [удобен для сохранения любого мутируемого значения](https://ru.reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables), по аналогии с тем, как вы используете поля экземпляра в классах.

Это возможно, поскольку `useRef()` создаёт обычный JavaScript-объект. Единственная разница между `useRef()` и просто созданием самого объекта `{current: ...}` — это то, что хук `useRef` даст один и тот же объект с рефом при каждом рендере.

Имейте в виду, что `useRef` _не_ уведомляет вас, когда изменяется его содержимое. Мутирование свойства `.current` не вызывает повторный рендер. Если вы хотите запустить некоторый код, когда React присоединяет или отсоединяет реф к узлу DOM, вы можете использовать [колбэк-реф](https://ru.reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node) вместо этого.

UseMemo()const `memoizedValue` = useMemo(() => computeExpensiveValue(`a`, `b`), [`a`, `b`]);

Возвращает [мемоизированное](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%BC%D0%BE%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F) значение.

Передайте «создающую» функцию и массив зависимостей. `useMemo` будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере.

Помните, что функция, переданная `useMemo`, запускается во время рендеринга. Не делайте там ничего, что вы обычно не делаете во время рендеринга. Например, побочные эффекты принадлежат `useEffect`, а не `useMemo`.

Если массив не был передан, новое значение будет вычисляться при каждом рендере.

**Вы можете использовать** `**useMemo**` **как оптимизацию производительности, а не как семантическую гарантию.** В будущем React может решить «забыть» некоторые ранее мемоизированные значения и пересчитать их при следующем рендере, например, чтобы освободить память для компонентов вне области видимости экрана. Напишите свой код, чтобы он по-прежнему работал без `useMemo`, а затем добавьте его для оптимизации производительности.
