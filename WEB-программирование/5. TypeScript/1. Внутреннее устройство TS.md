____

tags:  #TS #компилятор-TS 

keywords:
~~~
1. npm install -g typescript
	а. tsc index.ts
	б. node index.js
2. npm install -g ts-node
3. ts-node index.ts

npm i rimraf
npm i copyfiles --save dev
npm i npm-watch

~~~

_____
## Инициализация TS в проекте

TypeScript - это некое расширение, дополнение к языку JS , которое добавляет в язык статическую типизацию.

Для того, чтобы установить #TS в проект, необходимо:
~~~
npm install -g typescript
~~~

Компилируем наш ts-файл в js-файл для отображения запроса
~~~
tsc index.ts
~~~

Образовался файл index.js . Введем

~~~
node index.js
~~~

Данные отобразились.
Для того, чтобы не повторять данную операцию для оторбражения данных воспользуем следующим глобальным расширением для ts:

~~~
npm install -g ts-node
~~~

Для отображения данных и компиляции воспользуемся следующим кодом:
~~~
ts-node index.ts
~~~

Таким образом, мы в 1 действие преобразовали файл.

## Задача TS

Предположим, что у нас есть следующий пример кода:

```javascript
const message = "hello!";
message();
```

Как мы знаем из курса JS, такой код выполнится со следующей ошибкой:  
  
        **TypeError: message is not a function**  
  
Мы нашли проблему, но сложность состоит в том, что эту ошибку мы получим только в runtime. Как указывалось ранее, такие ошибки намного труднее отследить, и не всегда мы сможем найти их на стадии разработки, если выполнение кода не дойдет до участка с ошибкой. 
К примеру, если бы код выглядел так, ошибку бы мы могли получить только при выполнении определенного условия:

```javascript
const something = false;
const message = "hello!";
if (something) {
  message();
}
```

TypeScript предлагает следующее решение:

```javascript
const message: string = "hello!";
message();
```

В первой строке мы задали переменную message тип string. При дальнейшей попытке вызова этой переменной как функции мы получим следующую ошибку на стадии компиляции кода из TS в JS:  
   
        **This expression is not callable.  
        Type 'String' has no call signatures.**  
 
Код не будет скомпилирован, и мы сможем устранить ошибку сразу. Нам не нужно тестировать программу в runtime и пытаться создать ситуацию, при которой указанный выше код будет вызван и отобразит ошибку. Более того, нам не обязательно даже указывать тип:

```javascript

const message = "hello!";
message();
```

Аналогичный и полностью валидный JS код в TS не компилируется и выдает ошибку:  
   
        **This expression is not callable.  
        Type 'String' has no call signatures.**  
 
Это связано с тем, что TS уже знает, что переменная message имеет тип string на основании того, что мы присвоили ей строку "hello!".  
Указанный выше пример с if тоже всегда выдаст ошибку компиляции TS, он проверяет все возможные варианты развития событий за нас.

```javascript
const something = false;
const message = "hello!";
 
if (something) {
  message();
}
```

Сама установка TS уже помогла найти ошибку, а мы еще даже не начали использовать его систему типов на полную мощность. Мы поговорим подробнее о механизме автоматического выведения типов в следующем пункте.

## Компилятор TS

TypeScript помогает нам отлавливать ошибки **—** это здорово, но еще лучше то, что он позволяет нам избегать ошибок. #компилятор-TS знает:
-   какие свойства и методы есть у объекта; 
-   какой тип данных у переменной; 
-   какие аргументы нужно передать функции и т.д.. 

Поэтому он подсказывает эту информацию в момент написания кода. Для этого нам нужен только TS и IDE, которая его поддерживает. #TS будет передавать #IDE информацию о типах, а IDE, в свою очередь, отобразит необходимые подсказки.  
   
Рассмотрим следующий пример:  

![](https://platform.kata.academy/uploads/2022/7/9/Screenshot%202022-08-09%20at%2019.16.12_18_17_56.png)  

В момент написания кода IDE уже подсказала нам, какие методы есть у объекта res. 

Если мы попытаемся обратиться к методу, которого не существует, первым признаком ошибки для нас будет отсутствие подсказки. Если нас это не остановит, и мы введем название несуществующего метода, IDE мгновенно покажет нам ошибку о том, что такого метода нет. 

Нам не нужно даже компилировать проект, чтобы найти ошибку **—** мы видим ее на лету:  

![](https://platform.kata.academy/uploads/2022/7/9/Screenshot%202022-08-09%20at%2019.19.48_18_20_12.png)

Как указывалось ранее, TS **—** компилируемый язык. 
Результатом его компиляции является JS код.  
   
Этап компиляции нам необходим по той причине, что браузеры не могут исполнять 
TS **—** синтаксис этого языка им непонятен. 

Мы преобразуем TS в JS с помощью #aot (ahead-of-time) компиляции **—** этот этап полностью проходит перед исполнением. TS не компилируется и не исполняется в браузере, в момент исполнения наша программа для браузера выглядит как обычный JS код.  
   
Типы TS существуют исключительно на этапе разработки и используются только для нахождения ошибок до исполнения программы, поэтому не следует ожидать, что типы, указанные вами в коде, будут соблюдаться в runtime. Вся информация о типах теряется на стадии компиляции, и браузер уже ничего не знает о типах. Если ваш код удачно скомпилирован в JS, далее на TS полагаться не нужно **—** его типов в коде уже не существует. По этой же причине типы TS никак не влияют, к примеру, на результат JS оператора typeof и не могут ни основываться на том, что происходит в runtime, ни быть использованы там.  
   
Основная задача компиляции TS **—** получение списка ошибок типов в коде и удаление информации о типах, чтобы подготовить код для исполнения браузером. Побочная задача **—** преобразование JS кода в код других версий ECMAScript. 

## База работа с типами в TS

Тип - это набор значений
В JS всего 8 типов: [[1.1 Типы данных]]

1. TS добавляет слой статических типов
2. Типы существуют при компиляции или проверке исходного кода
3. Каждое место хранения данных имеет статический тип
4. Тип определяет возможные динамические значения.
5. Проверка типов гарантиует, что значения всегда будут соответствовать "прогнозу"
6. Проверка случится ещё до запуска кода

### Аннотация типов

Как сказать, что та или иная сущестность принадлежит конкретному типу.
~~~
let x: number;
~~~

TS не читает x, пока мы не назначим ему значение.
В большинстве случаев TS корректно определяет тип.

### Определения типа через выражения

Аннотация типа бывает сложносоставной
При необходимости использовании нескольких вариантов типов для переменной используется оператор |

### Псевдоним типа ( #aliases )

При частом использовании составного типа, ему задают псевдоним
~~~
type Score = number | string
const myScore: Score = 7
~~~
или
~~~
type Score = number | string
const myScore1: Score = '10';
~~~

Имена псевдонимов, как правило, с больших букв.

### Когда аннотация действительно нужна ?

Когда функция возвращает тип any и мы хотим уточнить значение
Когда обьявление переменной и присвоение ей значения происходит в разных строчках
Когда мы хотим, чтобы тип был сложносоставной и неопределялся автоматически

## Явная и неявная типизация, указание типов

Мы можем указать тип переменной явно с помощью следующего синтаксиса:

```javascript
let message: string = '5'
```

Объявленная переменная будет иметь тип string, и при попытке присвоить в нее значение другого типа мы получим ошибку.  
   
Несколькими уроками ранее мы говорили, что не всегда нужно явно указывать тип данных. Одна из важнейших концепций TS **—** автоматическое выведение типов.

```javascript
const something = false; // TS: boolean
let message = "hello!"; // TS: string
message = 5;
```

В указанном выше примере мы не задали типы переменным. Тем не менее, TS сам вывел их на основании того, какое значение им было присвоено. При попытке переопределить message значением типа “number” мы получим следующую ошибку:  

![](https://platform.kata.academy/uploads/2022/7/9/Screenshot%202022-08-09%20at%2019.25.23_18_25_44.png)  
  
С помощью механизма автоматического выведения типов мы получаем ряд удобств —
-   Нам не нужно писать слишком много типов вручную: достаточно описать тип в одном месте переданным значением или аннотацией типа и TS сделает всю остальную работу за нас, корректно выводя типы при дальнейшем использовании этой переменной в коде.
-   Мы можем легко изменять типы в одном месте за счет того, что типы не дублируются повсеместно. Если мы изменим тип в изначальном объявлении на некорректный, то во всех местах, где использовалась эта переменная, автоматически выведется новый тип, что может привести к ряду ошибок, по которым мы сможем легко найти места в коде, которые нужно исправить. 

Было до рефакторинга:

```javascript

let message = "hello!"; // TS: string
const anotherMessage = message // TS: string
console.log(anotherMessage.toUpperCase())
```

Стало после рефакторинга:

```javascript

let message: { text: string } = { text: “hello!” }; // TS: string
const anotherMessage = message // TS: string
 console.log(anotherMessage.toUpperCase())
```

Возникла ошибка:

![](https://platform.kata.academy/uploads/2022/7/9/Screenshot%202022-08-09%20at%2019.27.59_18_28_20.png)

## Транспиляция и полифиллинг

TS может частично исполнять роль Babel, преобразуя код из более новых версий ECMAScript в более старый. Этот процесс называется downleveling.  
   
К примеру, представим следующий код:

```javascript
`Hello ${person}, today is ${date.toDateString()}!`;
```

TS в зависимости от настроек может преобразовать его в следующий код:

```javascript
"Hello " + person + ", today is " + date.toDateString() + "!";
```

Это происходит, потому что template string (первый пример) **—** это синтаксис, добавленный в ECMAScript 6, в то время как TS был настроен так, чтобы компилировать код в более старую версию JS **—** например, ES5 или ES3. По умолчанию TS компилирует код в очень старую версию **—** в ES3. Это можно изменить с помощью настроек компилятора. Детальнее о том, как настраивать компилятор TS, мы поговорим позже.

## Настройки строгости

Помимо указанных ранее настроек компиляции, TS позволяет настроить целый ряд опций, влияющих на то, как строго TS будет компилировать наш код. Это необходимо для того, чтобы в каждом проекте можно было индивидуально настроить необходимые правила под нужды разработчиков. Тем не менее, основные правила TS отключить нельзя, речь идет исключительно о повышении строгости проверок.