#### 1. Что такое #VirtualDOM и зачем он нужен?  
Подробнее: [Что такое VirtualDOM](https://habr.com/ru/post/256965/)

#VirtualDOM  - то, почему #React обьект работает так быстро, легковесные обьекты.

##### Что такое #DOM и отличие от #VirtualDOM 

Главная проблема #DOM — он никогда не был рассчитан для создания динамического пользовательского интерфейса ( #UI ). Мы можем работать с ним, используя JavaScript и библиотеки наподобие jQuery, но их использование не решает проблем с производительностью.

Можем ли мы решить эту проблему? Похоже, что можем.

#VirtualDOM не является стандартом и в конечном итоге мы по-прежнему взаимодействуем с DOM, но делаем это как можно реже и более эффективно.
Вместо того, чтобы взаимодействовать с DOM напрямую, мы работаем с его легковесной копией. Мы можем вносить изменения в копию, исходя из наших потребностей, а после этого применять изменения к реальному DOM.  

При этом происходит сравнение DOM-дерева с его виртуальной копией, определяется разница и запускается перерисовка того, что было изменено.  
  
Такой подход работает быстрее, потому как не включает в себя все тяжеловесные части реального DOM.  

Но только если мы делаем это правильно. 
Есть две проблемы: когда именно делать повторную перерисовку DOM и как это сделать эффективно.

**Когда?**  
Когда данные изменяются и нуждается в обновлении.  
Есть два варианта узнать, что данные изменились:  

-   Первый из них — «dirty checking» (грязная проверка) заключается в том, чтобы опрашивать данные через регулярные промежутки времени и рекурсивно проверять все значения в структуре данных.
-   Второй вариант — «observable» (наблюдаемый) заключается в наблюдении за изменением состояния. Если ничего не изменилось, мы ничего не делаем. Если изменилось, мы точно знаем, что нужно обновить.

**Как?**  
Что делает этот подход действительно быстрым:  

-   Эффективные алгоритмы сравнения
-   Группировка операций чтения/записи при работе с DOM
-   Эффективное обновление только под-деревьев

Как вы понимаете, это не так просто и реализация может оказаться довольно сложной, но есть некоторые библиотеки, которые помогают реализовать этот подход в наших проектах.  
Одной из таких самых известных библиотек является React от команды разработчиков Facebook.  
  
##### Другие библиотеки и фреймворки

-   [virtual-dom](https://github.com/Matt-Esch/virtual-dom) — реализация Virtual DOM от Matt Esch, алгоритм сравнения отличий.
-   [Mithril](http://lhorie.github.io/mithril/) — Javascript-фреймворк для создания ярких приложений.
-   [Bobril](https://github.com/Bobris/Bobril) — Компонент-ориентированный фреймворк, вдохновленный подходами Mithril и ReactJs.
-   [cito.js](https://github.com/joelrich/citojs) — JavaScript-фреймворк для создания быстрых, масштабируемых и модульных веб-приложений.

##### Вывод

#VirtualDOM — это техника и набор библиотек / алгоритмов, которые позволяют нам улучшить производительность на клиентской стороне, избегая прямой работы с DOM путем работы с легким JavaScript-объектом, имитирующем DOM-дерево.  
  
Идея с использованием виртуального DOM отличная, хотя и не нова — мы давно знали, что прямая работа с DOM обходится дорого. Используя библиотеки наподобие React, мы можем повысить производительность приложений и сделать это очень просто.  


#### 2. Что такое #React?  
Подробнее: [[1.1.1 Знакомство с React]]

#React — это декларативная, эффективная и гибкая #JS-библиотека для создания пользовательских интерфейсов. Она позволяет вам собирать сложный #UI из маленьких изолированных кусочков кода, называемых «компонентами».

#React-компонент - это независимые блоки пользовательского интерфейса, которые могут иметь свое собственное поведение

Функции, которые возвращают #React-элемент должны начинаться с большой буквы.
Например, 

~~~
const Header = () = > return <h1>Hi</h1>
~~~

React создает легковесное дерево из JavaScript-объектов для имитации DOM-дерева. Затем он создает из них HTML, который вставляется или добавляется к нужному DOM-элементу, что вызывает перерисовку страницы в браузере.  

React — это библиотека, а не фреймворк, поэтому сравнивать его с Angular или Ember некорректно.  

#### 3. Как добавить #React на страницу?  

1. Для того, чтобы работать в #React необходимо применить скрипт:
```
npx create-react-app my-app
```

И подготовить директорию к работе, удалив шаблонные файлы проекта.

2. Привязываем терминал к проекту
~~~
cd my-app
~~~

#### 4. Что такое #JSX ? Можем ли мы использовать React без JSX?  
Подробнее: [[1.3.5 Знакомство с JSX]]

JSX производит «элементы» React. 

```
const name = 'Иван-Царевич';
const element = <h1>Здравствуй, {name}!</h1>;
```

JSX допускает использование любых корректных [JavaScript-выражений](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators) внутри фигурных скобок. 

JSX не является обязательным для работы с React. React можно использовать без JSX.
Подробнее [React без JSX](https://ru.reactjs.org/docs/react-without-jsx.html)

Например, вот код с JSX:

```
class Hello extends React.Component {
  render() {
    return <div>Привет, {this.props.toWhat}</div>;
  }
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<Hello toWhat="Мир" />);
```

Он может быть превращён в код без JSX:

```
class Hello extends React.Component {
  render() {
    return React.createElement('div', null, `Привет, ${this.props.toWhat}`);
  }
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(React.createElement(Hello, {toWhat: 'Мир'}, null));
```

#### 5. JSX, условный рендеринг, работа с коллекциями
##### Рендеринг

Для рендеринга React-элемента, сперва передайте #DOM-элемент в [`ReactDOM.createRoot()`](https://ru.reactjs.org/docs/react-dom-client.html#createroot), далее передайте #React-элемент в `root.render()`:

```
const root = ReactDOM.createRoot(
  document.getElementById('root')
);
const element = <h1>Hello, world</h1>;
root.render(element);
```

 На практике большинство React-приложений вызывают `root.render()` только один раз. В следующем разделе вы узнаете, как можно обновлять интерфейс при помощи [компонента с состоянием](https://ru.reactjs.org/docs/state-and-lifecycle.html).

##### Условный рендеринг
Подробнее: [Условный рендеринг](https://ru.reactjs.org/docs/conditional-rendering.html)

Условный рендеринг в React работает так же, как условные выражения работают в JavaScript. Бывает нужно объяснить React, как состояние влияет на то, какие компоненты требуется скрыть, а какие — отрендерить, и как именно. В таких ситуациях используйте [условный оператор](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%BD%D1%8B%D0%B9_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80) JavaScript или выражения подобные [`if`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/if...else).

Рассмотрим два компонента:

```
function UserGreeting(props) {
  return <h1>С возвращением!</h1>;
}

function GuestGreeting(props) {
  return <h1>Войдите, пожалуйста.</h1>;
}
```

Можно создать компонент `Greeting`, который отражает один из этих компонентов в зависимости от того, выполнен ли вход на сайт:

```
function Greeting(props) {
  const isLoggedIn = props.isLoggedIn;
  if (isLoggedIn) {    return <UserGreeting />;  }  return <GuestGreeting />;}
const root = ReactDOM.createRoot(document.getElementById('root')); 
// Попробуйте заменить на isLoggedIn={true}:
root.render(<Greeting isLoggedIn={false} />);
```

В этом примере рендерится различное приветствие в зависимости от значения пропа `isLoggedIn`.

В редких случаях может потребоваться позволить компоненту спрятать себя, хотя он уже и отрендерен другим компонентом. Чтобы этого добиться, верните `null` вместо того, что обычно возвращается на рендеринг.

##### Работа с коллекциями
Подробнее: [Работа с коллекциями](https://ru.hexlet.io/courses/js-react/lessons/jsx-collections/theory_unit)

#### 6. Зачем нужен #key в циклах?  

Каждому #JSX элементу в массиве нужно уникальное свойство #key 

#React использует #key , чтобы эффективно сравнивать элементы при обновлении
Не стоит делать ключи из индексов массива. Ключ типа #key считается одним из самых идеальных ключей, потому что он уникален для #React обьекта.

~~~
      <Task
        {...itemProps}
        key={id} // !
        id={id}
        deleteItem={() => deleteItem(id)}
        editItem={() => editItem(id)}
        onSubmitEdit={(event) => onSubmitEdit(event, id)}
        done={item.done}
        onToggleDone={() => onToggleDone(id)}
      />
~~~

#### 7. Какие различия между компонентом-классом и функциональным компонентом?  
Подробнее: [[1.3.4 React - компоненты]] , [[1.3.8.2 Компоненты и пропсы]] ,  [[1.4.2 Компоненты-классы ]], [Чем функциональные компоненты React отличаются от компонентов, основанных на классах?](https://habr.com/ru/company/ruvds/blog/444348/)

Функции, которые возвращают #React-элемент должны начинаться с большой буквы.
Например, 

~~~
const Header = () = > return <h1>Hi</h1>
~~~

Это имя затем можно использовать в #JSXX как будто это HTML-тег

##### Функциональный компонент

Функциональный компонент - это обычная функция JavaScript, возвращающая #JSX.

```
function Welcome(props) {
  return <h1>Привет, {props.name}</h1>;
}
```

Эта функция — компонент, потому что она получает данные в одном объекте («пропсы») в качестве параметра и возвращает React-элемент. Мы будем называть такие компоненты «функциональными», так как они буквально являются функциями.

##### namespace

Основные фишки #namespace в том, что они могут быть иерархическими, а реализацию одного пространства имён можно раскидывать по разным файлам. Модуль это просто вырожденный случай, где файл образует отдельный одноуровневый #namespace.

##### Компонент класса

Компонент класса - это расширяемый класс JavaScript, #React.

~~~
class Welcome extends React.Component {
  render() {
    return <h1>Привет, {this.props.name}</h1>;
  }
}
~~~

Классы используются, когда нужно хранить состояние через #props . Пропсы доступны через this.props.

Классы наследуют React.component , а через метод render() возвращается элемент.

##### Преобразование функционального компонента в классовый компонент

1.  Создаём [ES6-класс](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes) с таким же именем, указываем `React.Component` в качестве родительского класса
2.  Добавим в класс пустой метод `render()`
3.  Перенесём тело функции в метод `render()`
4.  Заменим `props` на `this.props` в теле `render()`
5.  Удалим оставшееся пустое объявление функции

```
class Clock extends React.Component {
  render() {
    return (
      <div>
        <h1>Привет, мир!</h1>
        <h2>Сейчас {this.props.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
```

Компонент никогда не должен что-то записывать в свои пропсы — вне зависимости от того, [функциональный он или классовый](https://ru.reactjs.org/docs/components-and-props.html#function-and-class-components).

#### 8. Что такое #children в #props?  
Подробнее: [краткое введение в props.children в React](https://codeburst.io/a-quick-intro-to-reacts-props-children-cb3d2fce4891)

{this.props.children}

```javascript
render() {
  if (this.props.appLoaded) {
    return (
      <div>
        <Header
          appName={this.props.appName}
          currentUser={this.props.currentUser}
        />
        {this.props.children}
      </div>
    );
  }
}
```

`this.props.children` делает, заключается в том, что  он используется для отображения всего, что вы включаете между открывающим и закрывающим тегами при вызове компонента._

Простой пример:

> Вот пример функции без сохранения состояния, которая используется для создания компонента. Опять же, поскольку это функция, здесь нет `this`ключевого слова, поэтому просто используйте`props.children`

```javascript
const Picture = (props) => {
  return (
    <div>
      <img src={props.src}/>
      {props.children}
    </div>
  )
}
```

> Этот компонент содержит объект `<img>`, который получает некоторые данные `props`, а затем отображает файлы `{props.children}`.

> Всякий раз, когда этот компонент вызывается, `{props.children}`он также будет отображаться, и это просто ссылка на то, что находится между открывающим и закрывающим тегами компонента.

```javascript
//App.js
render () {
  return (
    <div className='container'>
      <Picture key={picture.id} src={picture.src}>
          //what is placed here is passed as props.children  
      </Picture>
    </div>
  )
}
```

> Вместо того, чтобы вызывать компонент с самозакрывающимся тегом, `<Picture />`если вы вызываете его с полными открывающими и закрывающими тегами, `<Picture> </Picture>`вы можете разместить между ними дополнительный код.

> Это отделяет `<Picture>`компонент от его содержимого и делает его более пригодным для повторного использования.




#### 9. Что делает #setState? Функция setState первым аргументом может принять объект, а может функцию. Зачем нужна функция?  
Подробнее: [[1.4.3 State - состояние компонента]] , 

В #State хранится состояние (свойства) #React элемента, его можно инициализировать в конструкторе или в теле класса.

После того, как инициализировал #state его нельзя изменять - это возможно, но считается не правильной практикой, он предназначен для чтения.

Одно из самых важных аспектов #React заключается в том, чтобы обновить state используют #setState()

Функция #setState может принимать в виде аргумента функцию, этот аргумент - текущий state.

~~~
this.setState( (state)  => {
	return {
		count: state.count 1}
});
~~~

Происходит асинхронное обновление состояния state в зависимости от предыдущего значения.

#### 10. Как выполнить действие с новым состоянием стейта после #setState?  

##### Как использовать setState

Метод `setState()` планирует изменение объекта состояния (`state`) компонента. Когда состояние меняется, компонент рендерится повторно.

Используя новые состояния #State можно добавлять , удалять и обновлять элементы.

// Удалить элемент
~~~
setState() {
	...
	newArr = […oldArr.slice(0, idx), …oldArr.slice(idx 1)]
	...
}
~~~

// Добавить элемент
~~~
setState() {

	const newArr = [... oldArr , newItem] // добавить элемент в конец массива
	
	const newArr = [newItem, ...oldArr] // добавить элемент в начало массива

}

arr.push () - тоже изменение массива (нельзя выполнять на массивах из #State )
~~~

##### React.Component
Подробнее: [React.Component](https://ru.reactjs.org/docs/react-component.html)

В качестве первого аргумента `setState()`, вместо функции, вы можете передать объект:

```
setState(stateChange[, callback])
```

В нём образуется новое состояние после поверхностного объединения с `stateChange`. Например, установим количество товаров в корзине:

```
this.setState({quantity: 2})
```

Эта форма записи `setState()` также асинхронна, и несколько вызовов в течение одного цикла могут быть объединены вместе. Например, вам нужно увеличить количество элементов несколько раз в одном цикле. Результат этого можно представить так:

```
Object.assign(
  previousState,
  {quantity: state.quantity + 1},
  {quantity: state.quantity + 1},
  ...
)
```

Последующие вызовы будут переопределять значения из предыдущих вызовов того же цикла. Из-за этого количество увеличится только один раз. В случае, если следующее состояние зависит от текущего, мы рекомендуем использовать форму функции обновления:

```
this.setState((state) => {
  return {quantity: state.quantity + 1};
});
```

Для более подробной информации смотрите:

-   [Руководство по состоянию и жизненному циклу](https://ru.reactjs.org/docs/state-and-lifecycle.html)
-   [Продвинутый уровень: когда и почему группируются вызовы `setState()`?](https://stackoverflow.com/a/48610973/458193)
-   [Продвинутый уровень: почему `this.state` не обновляется сразу?](https://github.com/facebook/react/issues/11527#issuecomment-360199710)

---

##### Какая разница между `state` и `props`?

[`props`](https://ru.reactjs.org/docs/components-and-props.html) (намеренно сокращённо от англ. «properties» — свойства) и [`state`](https://ru.reactjs.org/docs/state-and-lifecycle.html) — это обычные JavaScript-объекты. Несмотря на то, что оба содержат информацию, которая влияет на то, что увидим после рендера, есть существенное различие: `props` передаётся _в_ компонент (служат как параметры функции), в то время как `state` находится _внутри_ компонента (по аналогии с переменными, которые объявлены внутри функции).

#### 11. Что такое контроллируемый компонент?  
Подробнее: [Контролируемый и неконтролируемый компонент](https://habr.com/ru/post/502034/)

Компонент становится контролируемым, когда вы устанавливаете его значение используя props. Вот и всё.  

  ![[Pasted image 20230320183637.png]]

onChange() - обновляет state, а state обновляется value элемента.

Давайте посмотрим на пример кода.

```
import React, { Component } from 'react';

class App extends Component {
    state = {
        message: ''
    }
    updateMessage = (newText) => {
        console.log(newText);
        this.setState(() => ({
            message: newText
        }));
    }
    render() {
        return (
            <div classname="App">
                <div classname="container">
                    <input type="text" placeholder="Your message here.." value="{this.state.message}" onchange="{(event)" ==""> this.updateMessage(event.target.value)}
                    />
                    <p>the message is: {this.state.message}</p>
                </div>
            </div>
        );
    }
}

export default App;
```

Если мы посмотрим на код для этого компонента, в строке 4 мы создаем объект состояния. Он содержит единственное свойство, которое называется `message`. Здесь хранится значение, введенное в текстовое поле.

Чтобы сохранить значение, нам нужно событие, которое будет запущено, когда пользователь вводит текст в поле. Как мы это делаем?

Если вы посмотрите на строки 19 и 20 кода, вы увидите, что:

1.  Текстовое поле имеет атрибут value, связанный со свойством сообщения в состоянии.
2.  У нас есть обработчик события `onChange`.

Эти 2 пункта говорят вам, что это контролируемый компонент.

Нам не нужен элемент формы на странице, чтобы компонент был контролируемым компонентом.

Когда вносятся изменения в любой из элементов ввода, имеющих обработчик события, он запускается.

Обработчик вызывает `setState()`, как вы можете видеть в строке 9 выше. Это обновляет состояние внутри компонента.

Вы никогда не должны устанавливать состояние прямо так:

```
this.state.message = 'dont update state like this';
```

Обновление состояния таким способом не вызовет повторную визуализацию компонента, а сделанные пользователем изменения не будут отображаться в пользовательском интерфейсе.

Когда обновление состояния происходит через `setState()`, это вызывает повторную визуализацию компонента, и вновь введенное значение отображается в элементе.

Поток данных является однонаправленным от состояния компонента к элементу ввода.

Работа с контролируемыми компонентами может быть немного громоздкой. Если на странице имеется большое количество элементов ввода, каждый элемент требует настройки с атрибутом значения и обработчиком события.

#### 12. Зачем нужны #eslint и #prettier?  

#ESLint необходим для подсветки ошибок и работы с описанными правилами. 
#Prettier служит для чтения правил и форматирования кода .

-   eslint – главный модуль линтера.
-   eslint-config-airbnb  – готовая конфигурация для использования стайлгайда Airbnb.
-   eslint-config-prettier  – позволяет ESLint и Prettier работать вместе.
-   eslint-plugin-import – предназначен для поддержки синтаксиса импорта/экспорта и управления путями к файлам. Подробнее можно прочитать в [документации плагина](https://github.com/benmosher/eslint-plugin-import).
-   eslint-plugin-jsx-a11y 
-   eslint-plugin-react  – добавляет специфические настройки линтинга для проектов React.
-   eslint-plugin-react-hooks
-   husky _дает возможность зацепиться за хуки git. Это значит, что вы можете выполнять некоторые действия перед тем, как изменения будут закоммичены и отправлены в удаленный репозиторий_ .
-   lint-staged  _позволяет запускать тесты/форматеры на измененных файлах в pre-commit-хуке_

1.  `lint` - проверяет все файлы на ошибки
2.  `lint:fix` - проверяет и исправляет те ошибки, которые может
3.  `format` - форматирует все файлы с помощью prettier

#### 13. Как работать с формами в react?
Подробнее: [[1.4.12 Работа с формами]]

Используем:
#onChange() чтобы получать текущее значение;
#onSubmit() - событие "отправки" формы;
e.preventDefault() - чтобы страница не перезагружалась.

HTML-элемент `<textarea>` в качестве текста отображает дочерний элемент:

```
<textarea>
  Привет! Тут просто немного текста внутри тега textarea
</textarea>
```

В HTML `<select>` создаёт выпадающий список. HTML-код в этом примере создаёт выпадающий список
```
<select>
  <option value="grapefruit">Грейпфрут</option>
  <option value="lime">Лайм</option>
  <option selected value="coconut">Кокос</option>
  <option value="mango">Манго</option>
</select>
```

В HTML `<input type="file">` позволяет пользователю выбрать один или несколько файлов для загрузки с устройства на сервер или управлять им через JavaScript с помощью [File API](https://developer.mozilla.org/ru/docs/Web/API/File/Using_files_from_web_applications).

```
<input type="file" />
```

