____

#### ERRORS #JS #типыданных #переменные 

~~~
Обычно вам нужно избегать ошибок, но в этом упражнении вы будете порождать ошибки. 
Это поможет вам понять, какие типы ошибок возникают в разных ситуациях, и привыкнуть распознавать их в будущем.

Вам нужно реализовать 2 функции. 
Ваша задача — породить две ошибки внутри специально созданных функций.

## reference

Сделайте так, чтобы код внутри функции reference порождал ошибку типа ReferenceError.

Вспомните, что ReferenceError возникает, когда используется несуществующий идентификатор (имя). Например, если ваша функция возвращает значение константы, но такой константы не существует. Или в каком-нибудь выражении (фрагмент кода, который вычисляется в значение, как формула) используется неизвестный идентификатор.

## type

Сделайте так, чтобы код внутри функции type порождал ошибку типа TypeError.

Вспомните, что TypeError возникает, когда вы используете неправильный тип. 
Например, если вы пытаетесь вызвать численную константу как функцию.

### ВАЖНО

Ошибки должны генерироваться внутри функций reference и type.

<b>ОТВЕТ НА ЗАДАЧУ</b>

function reference() {
    console.log(message)
}

function type() {
    const number = 21;
    number = 22;
    console.log(number)
}
~~~

#### Default To 

~~~
Реализуйте функцию defaultTo, которая принимает значение первым аргументом и его значение по-умолчанию вторым. Если первое значение null, NaN или undefined, то должно быть возвращено значение по-умолчанию. Если нет, то нужно вернуть само значение (первый аргумент).

<b>ОТВЕТ НА ЗАДАЧУ</b>

const defaultTo = (value, defaultValue) => {
    if (!value) {
        return defaultValue;
    } else {
        return value;
    }
}
console.log(defaultTo)
~~~

#### compareWithPrecision

~~~

Напишите функцию, которая сравнивает два числа с определенной погрешностью.

<b>ОТВЕТ НА ЗАДАЧУ</b>

function compareWithPrecision(a, b, precision) {
    return Math.abs(a - b) <= precision;
}  

console.log(compareWithPrecision)

~~~

#### Capitalize

~~~
Реализуйте функцию capitalize, которая принимает строку в качестве аргумента и возвращает новую строку, в которой первые буквы слов заглавные, а все остальные - строчные.

function capitalize(str){

let x = "";
  for (i = 0; i < str.length; i++) {
  if (str[i - 1] === " " || i === 0) {
x += str[i].toUpperCase();
} else {
x += str[i].toLowerCase();
}
}
return x;
}
~~~

#### Stop gninnipS My sdroW!

~~~~

Реализуйте функцию reverseLongWords, которая принимает строку в качестве аргумента и возвращает новую строку, в которой каждое слово, которое содержит 5 или больше символов, написана наоборот.

const reverseLongWords = (str) => {
  let arr = str.split(" ");

  for (let i = 0; i < arr.length; i++) {
    if (arr[i].length >= 5) {
      arr[i] = arr[i].split("").reverse().join("");
    }
  }
  return arr.join(" ");   
};

~~~~


#### Wrap Paragraph

~~~

На входе есть текст, разделенный переносами строк На выходе каждая строка должна быть обернута тегом. Обратите внимание! Никаких дополнительных символов (в том числе пробелов и переносов) не должно быть в итоговой строке. Только исходный текст + тэги

Реализуйте функцию wrapInParagraph, которая принимает на вход текст, разделененный переносами строк и возвращает новый текст, в котором каждая строка обернута в тег

function wrapInParagraph(str){

return str.split("\n").map(v => `<p>${v}</p>`).join("\n") 

}
~~~


_____

